<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-orientation" content="landscape">
    <title>Sinuca Avanﾃｧado - Mira Aprimorada</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        /* Estilos base e de reset */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: manipulation;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0d1b2a 0%, #1b263b 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            color: #E0FBFC;
            padding: 5px;
            overflow: hidden;
        }

        /* ------------------------------------------------------------------ */
        /* ESTRUTURA PRINCIPAL E CENTRALIZAﾃﾃグ */
        /* ------------------------------------------------------------------ */
        #gameWrapper {
            display: flex;
            align-items: center;
            justify-content: flex-start; 
            width: 100%;
            max-width: 1100px; 
            height: 98vh; 
            max-height: 550px; 
            flex-direction: column; 
            padding-top: 5px; 
        }
        
        #topControls {
            display: flex;
            gap: 15px;
            margin-bottom: 5px; 
            height: 40px;
            flex-shrink: 0;
            align-items: center;
        }

        #message {
            font-size: 14px;
            font-weight: 600;
            color: #FFD700;
            min-height: 20px;
            padding: 5px;
            flex-shrink: 0;
            width: 800px;
            text-align: center;
            margin-bottom: 0px; 
            text-shadow: 0 0 5px rgba(255, 215, 0, 0.4);
        }
        
        #gameLayout {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            min-height: 400px; 
        }
        
        #gameContainer {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            padding: 0 5px;
            flex-shrink: 1; 
        }

        /* Canvas (Mesa de Sinuca) */
        #canvas {
            border: 6px solid #4a3424;
            box-shadow: 0 5px 30px rgba(0,0,0,0.9), inset 0 0 30px rgba(0,0,0,0.5);
            cursor: none;
            background: #0a5f0a;
            border-radius: 8px;
            width: 800px;
            height: 400px;
            touch-action: none;
            flex-shrink: 0;
            margin: 0;
        }
        
        /* Media Query para mobile horizontal */
        @media (max-width: 1024px) {
            #gameWrapper {
                max-width: 100%;
                padding: 0;
                padding-top: 2px;
            }
            #canvas {
                width: 70vw; 
                height: 35vw; 
                max-height: 350px;
                max-width: 700px;
            }
            #message {
                width: 100%;
                font-size: 12px;
            }
            #playerSidebar {
                 margin-right: 2px;
                 width: 80px; 
                 gap: 10px;
                 max-height: 350px;
            }
            .player-card h4 {
                 font-size: 10px; 
            }
            .player-details p {
                 font-size: 8px;
            }
            #scoreContainer {
                width: 120px; 
                max-height: 350px;
            }
            #scoreContainer h3 {
                font-size: 12px;
            }
            .sunk-ball {
                width: 14px;
                height: 14px;
                font-size: 8px;
            }
        }

        /* ------------------------------------------------------------------ */
        /* SIDEBAR ESQUERDA: CARDS DOS JOGADORES */
        /* ------------------------------------------------------------------ */
        #playerSidebar {
            width: 120px; 
            height: 100%;
            max-height: 400px;
            margin-right: 5px; 
            display: flex;
            flex-direction: column;
            justify-content: center; 
            align-items: center;
            padding: 8px 0; 
            gap: 15px; 
        }

        .player-card {
            --progress: 100%; 
            --neon-color: #00A896;
            --base-color: #1a273a;
            --border-width: 4px; /* Nova variﾃ｡vel para largura da borda */
            
            background: linear-gradient(145deg, #1f3044, #121c29);
            border-radius: 12px; 
            padding: 8px;
            width: 100%;
            box-shadow: 0 4px 15px rgba(0,0,0,0.6);
            transition: all 0.3s ease, transform 0.3s, background 0.3s;
            position: relative;
            border: var(--border-width) solid var(--base-color); /* Borda padrﾃ｣o */
            overflow: hidden;
        }

        /* ESTILOS DE PROGRESSO ATUALIZADOS COM BORDER-IMAGE */
        
        /* Ocultei a div .timer-display pois nﾃ｣o ﾃｩ mais necessﾃ｡ria para esta tﾃｩcnica */
        .timer-display {
             display: none; 
        }
        
        .player-card.active {
            transform: scale(1.05);
            background: linear-gradient(145deg, #2a405a, #1a273a);
            box-shadow: 0 6px 25px var(--neon-color, rgba(0,168,150,0.5));
            animation: none; 
            
            /* Efeito de Borda Animada para Progresso */
            border-style: solid;
            border-width: var(--border-width);
            border-image-source: conic-gradient(
                var(--neon-color) var(--progress), 
                transparent var(--progress)
            );
            border-image-slice: 1;
            border-image-width: var(--border-width);
            transition: border-image-source 1s linear; /* Suaviza a atualizaﾃｧﾃ｣o do progresso */
        }
        
        /* Estilo para quando o tempo estﾃ｡ baixo */
        .player-card.active[data-time-low='true'] {
            animation: neon-pulse-low 0.7s ease-in-out infinite alternate;
            /* Adiciona um pulso de cor na borda */
            border-image-source: conic-gradient(
                #FF4500 var(--progress), 
                transparent var(--progress)
            );
        }

        @keyframes neon-pulse-low {
            0% { box-shadow: 0 0 10px var(--neon-color); }
            100% { box-shadow: 0 0 20px var(--neon-color), 0 0 30px var(--neon-color); }
        }
        
        /* Remove a borda da classe inativa para que a cor base apareﾃｧa */
        .player-card:not(.active) {
            border: var(--border-width) solid var(--base-color);
            border-image: none;
            transition: all 0.3s ease;
        }

        .player-header {
            display: flex;
            align-items: center;
            margin-bottom: 5px; 
        }
        
        .player-info {
            position: relative;
            z-index: 2;
        }

        .profile-pic {
            width: 35px; 
            height: 35px;
            border-radius: 50%;
            margin-right: 5px; 
            background: #36495E;
            border: 2px solid var(--neon-color, #00A896);
            overflow: hidden;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px; 
            color: #E0FBFC;
            box-shadow: 0 0 8px rgba(0,168,150,0.4);
            transition: transform 0.3s, box-shadow 0.3s;
        }
        
        .player-card h4 {
            display: none; 
        }
        
        .player-details {
            padding-left: 4px;
            border-left: 2px solid rgba(255,255,255,0.2);
        }
        
        .player-details p {
            font-size: 10px;
            opacity: 0.95;
            line-height: 1.3; 
            margin: 1px 0; 
        }

        .player-details .ball-type {
            font-weight: bold;
            color: #4A90E2; 
        }
        .player-details span#p1Balls, .player-details span#p2Balls {
             font-weight: bold;
             color: #FFD700;
        }
        
        .player-effect {
            margin-top: 5px; 
            padding: 3px; 
            background: rgba(0,0,0,0.25);
            border-radius: 6px; 
            text-align: center;
            font-size: 8px; 
            color: #FFD700;
            box-shadow: inset 0 0 4px rgba(255,215,0,0.25);
        }
        
        .player-effect span {
            font-weight: bold;
            color: var(--neon-color, #00A896); 
        }
        
        /* PLACAR (SCORE CONTAINER) e CONTROLES permanecem inalterados */
        #scoreContainer {
            width: 150px; 
            height: 100%;
            max-height: 400px;
            margin-left: 5px; 
            background: linear-gradient(145deg, #0e1a2b, #070e17);
            border-radius: 12px;
            padding: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.6), inset 0 0 10px rgba(0,0,0,0.3);
            flex-shrink: 0;
        }
        
        #scoreContainer h3 {
            font-size: 15px;
            text-align: center;
            color: #E0FBFC;
            margin-bottom: 10px;
            border-bottom: 2px solid #00A896;
            padding-bottom: 5px;
            text-shadow: 0 0 5px rgba(0,168,150,0.5);
        }
        
        #sunkBallsScroll {
            max-height: 350px;
            overflow-y: auto;
            padding-right: 5px;
        }
        
        .sunk-group {
            margin-bottom: 10px;
            padding: 5px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
        }
        
        .sunk-group h4 {
            font-size: 11px;
            color: #A9D6E5;
            margin: 0 0 5px;
            font-weight: bold;
            text-transform: uppercase;
        }
        
        .balls-row {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            min-height: 20px;
        }
        
        .sunk-ball {
            width: 18px; 
            height: 18px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
            color: black;
            border: 2px solid rgba(255,255,255,0.6);
            box-shadow: inset 0 0 5px rgba(0,0,0,0.8), 0 2px 5px rgba(0,0,0,0.3); 
            line-height: 1;
            transition: transform 0.1s;
        }

        .sunk-ball.eight {
            background-color: black !important;
            color: white !important;
            border: 2px solid #FFD700;
        }

        /* Scrollbar styles (customized for dark theme) */
        #sunkBallsScroll::-webkit-scrollbar {
            width: 6px;
        }

        #sunkBallsScroll::-webkit-scrollbar-track {
            background: #0e1a2b;
            border-radius: 10px;
        }

        #sunkBallsScroll::-webkit-scrollbar-thumb {
            background: #36495E;
            border-radius: 10px;
        }

        #sunkBallsScroll::-webkit-scrollbar-thumb:hover {
            background: #506a86;
        }


        /* ------------------------------------------------------------------ */
        /* CONTROLES */
        /* ------------------------------------------------------------------ */
        .control-btn {
            font-size: 18px;
            background: linear-gradient(45deg, #4A90E2 0%, #764ba2 100%); 
            color: white;
            border: none;
            cursor: pointer;
            font-weight: bold;
            transition: transform 0.2s, box-shadow 0.2s, background 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 40px; 
            height: 40px; 
            border-radius: 50%;
            flex: none;
            box-shadow: 0 4px 15px rgba(0,0,0,0.6);
            z-index: 10;
        }
        
        .control-btn i {
            font-size: 20px; 
        }
        
        .control-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(0,0,0,0.8);
        }

        .control-btn:active {
            transform: scale(0.95);
        }
        
        #resetBtn {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
        }

        /* ------------------------------------------------------------------ */
        /* MODAL DE EFEITO (VISUAL MELHORADO) */
        /* ------------------------------------------------------------------ */
        #effectModal {
            position: fixed;
            left: 50%;
            bottom: 20px;
            transform: translateX(-50%);
            width: 100%;
            max-width: 260px; 
            background: rgba(10, 25, 40, 0.95); /* Fundo escuro */
            backdrop-filter: blur(5px);
            border: 2px solid #4A90E2; /* Borda Neon Azul */
            border-radius: 20px;
            padding: 15px; 
            display: none;
            flex-direction: column;
            align-items: center;
            z-index: 1000;
            box-shadow: 0 0 25px rgba(74, 144, 226, 0.8), inset 0 0 10px rgba(74, 144, 226, 0.5); /* Sombra Neon */
            animation: slideUp 0.4s ease-out;
        }
        
        @keyframes slideUp {
            from { bottom: -100px; opacity: 0; }
            to { bottom: 20px; opacity: 1; }
        }

        #effectControl h3 {
             font-size: 16px;
             margin-bottom: 5px;
             color: #E0FBFC;
             text-shadow: 0 0 5px #4A90E2;
        }
        
        #effectBoardWrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        #effectBoard {
            width: 140px;
            height: 140px;
            background-color: #1a3450; /* Fundo mais escuro */
            border-radius: 50%;
            border: 3px solid #00A896; /* Borda Neon Verde */
            position: relative;
            cursor: pointer;
            box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.8), 0 0 10px rgba(0, 168, 150, 0.6);
        }

        #effectMarker {
            width: 18px;
            height: 18px;
            background-color: #FF4500; /* Laranja Vﾃｭvido */
            border-radius: 50%;
            position: absolute;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 15px rgba(255, 69, 0, 1); /* Glow Forte */
        }

        #effectLabels {
            position: absolute;
            width: 100%;
            height: 100%;
        }

        .effect-label {
            position: absolute;
            font-size: 9px;
            color: #ddd;
            font-weight: bold;
            text-shadow: 0 0 3px black;
        }
        .effect-label.top { top: 8px; left: 50%; transform: translateX(-50%); }
        .effect-label.bottom { bottom: 8px; left: 50%; transform: translateX(-50%); }
        .effect-label.left { left: 8px; top: 50%; transform: translateY(-50%); }
        .effect-label.right { right: 8px; top: 50%; transform: translateY(-50%); }

        #effectDisplayWrapper {
            margin-top: 5px;
            font-size: 12px;
            color: #00A896;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(0, 168, 150, 0.4);
        }
        
        #powerBar {
            width: 100%;
            height: 15px;
            background-color: #0d1b2a;
            border: 1px solid #4A90E2;
            border-radius: 8px;
            overflow: hidden;
            margin-top: 10px;
        }
        
        #powerFill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #00A896, #4A90E2, #FFD700);
            transition: width 0.1s linear;
        }
        
        #closeEffectBtn {
            margin-top: 15px;
            width: 80%;
            height: 35px;
            border-radius: 18px;
            font-size: 14px;
            background: linear-gradient(45deg, #00A896, #0077B6);
            color: white;
            border: none;
            cursor: pointer;
            box-shadow: 0 4px 10px rgba(0, 168, 150, 0.5);
            transition: all 0.2s;
        }

        #closeEffectBtn:hover {
            background: linear-gradient(45deg, #0077B6, #00A896);
            transform: scale(1.05);
        }
    </style>
</head>
<body>
    <div id="gameWrapper">
        
        <div id="topControls">
            <button class="control-btn" id="effectBtn" title="Ajustar Efeito / Rotaﾃｧﾃ｣o"><i class="fas fa-bullseye"></i></button>
            <button class="control-btn" id="resetBtn" title="Reiniciar Jogo"><i class="fas fa-redo-alt"></i></button>
        </div>
        
        <div id="message"></div> 

        <div id="gameLayout">
            
            <div id="playerSidebar">
                <div class="player-card" id="player1Card">
                    <div class="timer-display" id="timeP1">
                        <div class="timer-progress"></div>
                    </div>
                    <div class="player-header">
                         <div class="profile-pic">
                            <span style="font-size: 20px;">側</span> 
                         </div>
                        <div class="player-info">
                            <div class="player-details">
                                <p>Tipo: <span class="ball-type" id="p1Type">-</span></p>
                                <p>Faltam: <span id="p1Balls">7</span></p>
                            </div>
                        </div>
                    </div>
                    
                    <div class="player-effect">Efeito: <span id="p1Effect">Centro</span></div>
                </div>

                <div class="player-card" id="player2Card">
                    <div class="timer-display" id="timeP2">
                        <div class="timer-progress"></div>
                    </div>
                     <div class="player-header">
                         <div class="profile-pic">
                            <span style="font-size: 20px;">則</span>
                         </div>
                        <div class="player-info">
                             <div class="player-details">
                                <p>Tipo: <span class="ball-type" id="p2Type">-</span></p>
                                <p>Faltam: <span id="p2Balls">7</span></p>
                            </div>
                        </div>
                    </div>

                    <div class="player-effect">Efeito: <span id="p2Effect">Centro</span></div>
                </div>
            </div>
            
            <div id="gameContainer">
                <canvas id="canvas" width="800" height="400"></canvas>
            </div>

            <div id="scoreContainer">
                <h3>竺 PLACAR ENCAﾃ②PADAS</h3>
                <div id="sunkBallsScroll">
                    <div class="sunk-group">
                        <h4>LISAS (1-7)</h4>
                        <div class="balls-row" id="sunkLisas"></div>
                    </div>
                    <div class="sunk-group">
                        <h4>LISTRADAS (9-15)</h4>
                        <div class="balls-row" id="sunkListradas"></div>
                    </div>
                    <div class="sunk-group">
                        <h4>BOLA 8</h4>
                        <div class="balls-row" id="sunkOito"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="effectModal">
        <div id="effectControl">
            <h3>劇 AJUSTE DE EFEITO (ROTAﾃﾃグ)</h3>
            <p style="font-size: 10px; margin-bottom: 5px; color: #9AADC9;">Arraste para definir o ponto de contato na bola branca.</p>
            
            <div id="effectBoardWrapper">
                <div id="effectBoard">
                    <div id="effectMarker"></div>
                    <div id="effectLabels">
                        <div class="effect-label top">TOP (MAIOR VEL. P/ FRENTE)</div>
                        <div class="effect-label bottom">BOTTOM (MAIOR REVERSﾃグ)</div>
                        <div class="effect-label left">ESPINAL ESQ.</div>
                        <div class="effect-label right">ESPINAL DIR.</div>
                    </div>
                </div>
            </div>
            
            <div id="effectDisplayWrapper">Efeito: <span id="effectDisplay">Centro</span></div>
            
            <div id="powerBar">
                <div id="powerFill"></div>
            </div>
            
            <button class="control-btn" id="closeEffectBtn">FECHAR</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const CANVAS_WIDTH = 800;
        const CANVAS_HEIGHT = 400;
        const MARGIN = 35; 
        const HEAD_STRING_X = 200; 

        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;

        const config = {
            ballRadius: 10,
            friction: 0.99, 
            rollingFriction: 0.985, 
            rollingThreshold: 0.5, 
            pocketRadius: 30,
            maxPower: 30,
            cushionRestitution: 0.85, 
            effectPower: {x: 0, y: 0}
        };

        const MAX_TIME = 25; 

        const timer = {
            interval: null,
            timeRemaining: MAX_TIME,
            
            start: function() {
                if (this.interval) clearInterval(this.interval);
                this.timeRemaining = MAX_TIME;
                this.updateUI();
                
                this.interval = setInterval(() => {
                    this.timeRemaining--;
                    this.updateUI();

                    if (this.timeRemaining <= 0) {
                        clearInterval(this.interval);
                        handleTimeOut();
                    }
                }, 1000);
            },
            stop: function() {
                if (this.interval) clearInterval(this.interval);
                this.interval = null;
            },
            
            // FUNﾃﾃグ updateUI MELHORADA PARA BORDER-IMAGE PROGRESS BAR
            updateUI: function() {
                const p = gameState.currentPlayer;
                const activeCard = document.getElementById(`player${p}Card`);
                const inactiveCard = document.getElementById(`player${p === 1 ? 2 : 1}Card`);
                
                const progress = this.timeRemaining / MAX_TIME;
                let activeColor = '#00A896'; // Padrﾃ｣o
                let isTimeLow = false;

                if (this.timeRemaining <= 5) {
                    activeColor = '#E74C3C'; // Vermelho
                    isTimeLow = true;
                } else if (this.timeRemaining <= 10) {
                    activeColor = '#F39C12'; // Amarelo
                } 
                
                // Progressﾃ｣o de 100% (comeﾃｧo) atﾃｩ 0% (esgotado)
                const progressPercent = progress * 100;
                
                // Aplica a variﾃ｡vel CSS para o border-image conic-gradient
                activeCard.style.setProperty('--progress', `${progressPercent}%`);
                activeCard.style.setProperty('--neon-color', activeColor);
                activeCard.classList.add('active');
                activeCard.dataset.timeLow = isTimeLow; 
                
                inactiveCard.classList.remove('active');
                inactiveCard.dataset.timeLow = false;
                inactiveCard.style.setProperty('--progress', '0%');
                inactiveCard.style.setProperty('--neon-color', '#00A896');
            }
        };
        
        function handleTimeOut() {
            showMessage(`TEMPO ESGOTADO! Jogador ${gameState.currentPlayer} perdeu a vez.`);
            switchPlayer(true);
        }
        
        const pockets = [
            {x: 30, y: 30, targetX: 10, targetY: 10},
            {x: CANVAS_WIDTH / 2, y: 20, targetX: CANVAS_WIDTH / 2, targetY: 10},
            {x: CANVAS_WIDTH - 30, y: 30, targetX: CANVAS_WIDTH - 10, targetY: 10},
            {x: 30, y: CANVAS_HEIGHT - 30, targetX: 10, targetY: CANVAS_HEIGHT - 10},
            {x: CANVAS_WIDTH / 2, y: CANVAS_HEIGHT - 20, targetX: CANVAS_WIDTH / 2, targetY: CANVAS_HEIGHT - 10},
            {x: CANVAS_WIDTH - 30, y: CANVAS_HEIGHT - 30, targetX: CANVAS_WIDTH - 10, targetY: CANVAS_HEIGHT - 10}
        ];

        let gameState = {
            currentPlayer: 1,
            player1Type: null,
            player2Type: null,
            whiteBall: null,
            balls: [],
            cue: {x: 0, y: 0, power: 0, angle: 0, visible: false},
            isDragging: false,
            isWhiteBallDragging: false, 
            isWhiteBallInHand: false,   
            gameOver: false,
            shotInProgress: false,
            firstBallHit: null, 
            ballsPocketedInShot: [],
            sunkBalls: {
                lisas: [],
                listradas: [],
                oito: [],
                branca: [] 
            } 
        };

        const ballColors = [
            '#FFFF00', '#0000FF', '#FF0000', '#800080', '#FF8C00', 
            '#008000', '#8B0000', '#000000', '#FFFF00', '#0000FF',
            '#FF0000', '#800080', '#FF8C00', '#008000', '#8B0000'
        ];
        
        class Ball {
            constructor(x, y, number) {
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
                this.number = number;
                this.radius = config.ballRadius;
                this.pocketed = false;
                this.isCue = number === 0;
                this.isEight = number === 8;
                this.isStriped = number > 8 && number < 16;
                this.isSolid = number > 0 && number < 8;
                this.color = this.isCue ? '#FFFFFF' : ballColors[number - 1];
                this.rotationAngle = 0; 
                this.isRolling = false;
                this.isFalling = false; 
                this.pocketTarget = null;
                this.currentRadius = config.ballRadius;
                this.pocketTimer = 0;
                this.maxPocketTime = 30; 
            }

            update() {
                if (this.pocketed) return;
                
                if (this.isFalling) {
                    this.pocketTimer++;
                    
                    const t = this.pocketTimer / this.maxPocketTime;
                    this.x = this.pocketTarget.x * t + this.x * (1 - t);
                    this.y = this.pocketTarget.y * t + this.y * (1 - t);
                    
                    this.currentRadius = config.ballRadius * (1 - t);
                    
                    this.vx *= 0.9;
                    this.vy *= 0.9;

                    if (this.pocketTimer >= this.maxPocketTime) {
                        this.pocketed = true;
                        handlePocket(this); 
                    }
                    return;
                }

                const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                
                if (speed > 0.01) {
                    this.x += this.vx;
                    this.y += this.vy;
                    
                    if (speed > config.rollingThreshold) {
                        this.vx *= config.rollingFriction; 
                        this.vy *= config.rollingFriction;
                        this.isRolling = true;
                        
                        const rotationSpeed = speed / this.radius;
                        this.rotationAngle += rotationSpeed * 0.15; 
                    } else {
                        this.vx *= config.friction; 
                        this.vy *= config.friction;
                        this.isRolling = false;
                    }

                    if (this.rotationAngle > Math.PI * 2) this.rotationAngle -= Math.PI * 2;
                    if (this.rotationAngle < -Math.PI * 2) this.rotationAngle += Math.PI * 2;
                    
                } else {
                    this.vx = 0;
                    this.vy = 0;
                    this.isRolling = false;
                }

                // Colisﾃ｣o com as tabelas
                
                // Tabela esquerda e direita (buracos intermediﾃ｡rios)
                if ((this.y < MARGIN + 40 || this.y > CANVAS_HEIGHT - MARGIN - 40) ||
                    (this.x > MARGIN + 40 && this.x < CANVAS_WIDTH - MARGIN - 40)) 
                {
                    // Tabelas superiores e inferiores (com gap no meio)
                    if (this.y - this.radius < MARGIN && (this.x < CANVAS_WIDTH / 2 - config.pocketRadius * 0.7 || this.x > CANVAS_WIDTH / 2 + config.pocketRadius * 0.7)) {
                        this.y = MARGIN + this.radius;
                        this.vy *= -config.cushionRestitution;
                    }
                    if (this.y + this.radius > CANVAS_HEIGHT - MARGIN && (this.x < CANVAS_WIDTH / 2 - config.pocketRadius * 0.7 || this.x > CANVAS_WIDTH / 2 + config.pocketRadius * 0.7)) {
                        this.y = CANVAS_HEIGHT - MARGIN - this.radius;
                        this.vy *= -config.cushionRestitution;
                    }
                }

                // Tabela esquerda e direita
                if (this.x - this.radius < MARGIN) {
                    this.x = MARGIN + this.radius;
                    this.vx *= -config.cushionRestitution;
                }
                if (this.x + this.radius > CANVAS_WIDTH - MARGIN) {
                    this.x = CANVAS_WIDTH - MARGIN - this.radius;
                    this.vx *= -config.cushionRestitution;
                }
                
                // Colisﾃ｣o com os bolsos
                for (let pocket of pockets) {
                    const dx = this.x - pocket.x;
                    const dy = this.y - pocket.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < config.pocketRadius * 0.9 && !this.isFalling) { 
                        this.isFalling = true;
                        this.pocketTarget = pocket;
                        this.currentRadius = this.radius;
                        this.pocketTimer = 0;
                        this.vx = (pocket.x - this.x) * 0.1;
                        this.vy = (pocket.y - this.y) * 0.1;
                    }
                }
            }
            
            draw() {
                if (this.pocketed) return;

                ctx.save();
                
                ctx.shadowColor = 'rgba(0,0,0,0.8)';
                ctx.shadowBlur = 10;
                ctx.shadowOffsetX = 3;
                ctx.shadowOffsetY = 3;

                ctx.translate(this.x, this.y);
                
                if (this.number !== 0) { 
                    ctx.rotate(this.rotationAngle);
                }

                const r = this.isFalling ? this.currentRadius : this.radius;

                // Desenho da bola (Sﾃｳlida, Listrada, 8, Branca)
                if (this.isStriped) {
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(0, 0, r, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.shadowColor = 'transparent';
                    
                    ctx.save();
                    
                    ctx.beginPath();
                    ctx.arc(0, 0, r, 0, Math.PI * 2);
                    ctx.clip();
                    
                    // Faixa branca central
                    ctx.fillStyle = '#FFFFFF';
                    const stripeWidth = r * 0.8; 
                    ctx.fillRect(-stripeWidth / 2, -r, stripeWidth, r * 2);

                    // Faixas brancas laterais
                    const sideStripeWidth = r * 0.1;
                    const offset = r * 0.8;
                    
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillRect(-offset - sideStripeWidth, -r, sideStripeWidth, r * 2);
                    ctx.fillRect(offset, -r, sideStripeWidth, r * 2);

                    ctx.restore();
                } else {
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(0, 0, r, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.shadowColor = 'transparent';

                // Reflexo de brilho
                const highlightX = -r * 0.4;
                const highlightY = -r * 0.4;

                const highlightGradient = ctx.createRadialGradient(
                    highlightX, highlightY, 0,
                    highlightX, highlightY, r * 0.8
                );
                highlightGradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
                highlightGradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.4)');
                highlightGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                
                ctx.fillStyle = highlightGradient;
                ctx.beginPath();
                ctx.arc(highlightX, highlightY, r * 0.8, 0, Math.PI * 2);
                ctx.fill();

                // Detalhe do nﾃｺmero da bola 
                if (this.number !== 0) {
                        
                    ctx.fillStyle = '#FFFFFF';
                    ctx.beginPath();
                    ctx.arc(0, 0, r * 0.55, 0, Math.PI * 2); 
                    ctx.fill();

                    ctx.fillStyle = '#000000';
                    ctx.font = 'bold 11px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
                    ctx.shadowBlur = 3;
                    ctx.fillText(this.number, 0, 0);
                        
                }

                ctx.restore(); 
            }
        }
        
        function handleCollisions() {
             for (let i = 0; i < gameState.balls.length; i++) {
                for (let j = i + 1; j < gameState.balls.length; j++) {
                    const b1 = gameState.balls[i];
                    const b2 = gameState.balls[j];

                    if (b1.pocketed || b2.pocketed || b1.isFalling || b2.isFalling) continue;

                    const dx = b2.x - b1.x;
                    const dy = b2.y - b1.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < b1.radius + b2.radius) {

                        // Lﾃｳgica de primeira bola tocada
                        if (gameState.shotInProgress) {
                            if (b1.number === 0 && b2.number !== 0 && gameState.firstBallHit === null) {
                                gameState.firstBallHit = b2.isEight ? 'oito' : (b2.isStriped ? 'listrada' : 'lisa');
                            }
                            else if (b2.number === 0 && b1.number !== 0 && gameState.firstBallHit === null) {
                                gameState.firstBallHit = b1.isEight ? 'oito' : (b1.isStriped ? 'listrada' : 'lisa');
                            }
                        }

                        // Colisﾃ｣o: Conservaﾃｧﾃ｣o de momento
                        const angle = Math.atan2(dy, dx);
                        const sin = Math.sin(angle);
                        const cos = Math.cos(angle);

                        // Rotaﾃｧﾃ｣o do sistema de coordenadas
                        const vx1 = b1.vx * cos + b1.vy * sin;
                        const vy1 = b1.vy * cos - b1.vx * sin;
                        const vx2 = b2.vx * cos + b2.vy * sin;
                        const vy2 = b2.vy * cos - b2.vx * sin;

                        // Troca de velocidades no eixo X
                        const finalVx1 = vx2;
                        const finalVx2 = vx1;
                        
                        // Rotaﾃｧﾃ｣o de volta ao sistema original
                        b1.vx = finalVx1 * cos - vy1 * sin;
                        b1.vy = vy1 * cos + finalVx1 * sin;
                        b2.vx = finalVx2 * cos - vy2 * sin;
                        b2.vy = vy2 * cos + finalVx2 * sin;

                        // Separaﾃｧﾃ｣o para evitar grudar
                        const overlap = b1.radius + b2.radius - dist;
                        b1.x -= overlap * cos / 2;
                        b1.y -= overlap * sin / 2;
                        b2.x += overlap * cos / 2;
                        b2.y += overlap * sin / 2;
                    }
                }
            }
        }
        
        function handlePocket(ball) {
            
            if (!ball.pocketed) return; 

            gameState.ballsPocketedInShot.push(ball);
            
            if (ball.isCue) {
                gameState.sunkBalls.branca.push(0);
                showMessage('FALTA! Branca encaﾃｧapada.');
                return;
            }

            if (ball.isEight) {
                if (!gameState.sunkBalls.oito.includes(8)) {
                    gameState.sunkBalls.oito.push(8);
                }
            } else if (ball.isSolid) {
                if (!gameState.sunkBalls.lisas.includes(ball.number)) {
                    gameState.sunkBalls.lisas.push(ball.number);
                }
            } else if (ball.isStriped) {
                if (!gameState.sunkBalls.listradas.includes(ball.number)) {
                     gameState.sunkBalls.listradas.push(ball.number);
                }
            }

            updateSunkBallsUI(); 

            if (ball.isEight) {
                const ownBallsRemaining = getOwnBallsRemaining(gameState.currentPlayer);
                
                if (ownBallsRemaining > 0 || gameState.player1Type === null) {
                    gameState.gameOver = true;
                    showMessage(`逐 JOGADOR ${gameState.currentPlayer === 1 ? 2 : 1} VENCEU! Bola 8 encaﾃｧapada cedo/com falta!`);
                    timer.stop();
                } else {
                    gameState.gameOver = true;
                    showMessage(`脂 JOGADOR ${gameState.currentPlayer} VENCEU! 脂`);
                    timer.stop();
                }
                return;
            }

            if (gameState.player1Type === null) {
                if (ball.isStriped) {
                    gameState.player1Type = gameState.currentPlayer === 1 ? 'listrada' : 'lisa';
                    gameState.player2Type = gameState.currentPlayer === 1 ? 'lisa' : 'listrada';
                } else {
                    gameState.player1Type = gameState.currentPlayer === 1 ? 'lisa' : 'listrada';
                    gameState.player2Type = gameState.currentPlayer === 1 ? 'listrada' : 'lisa';
                }
            }

            updateUI();
        }

        function updateSunkBallsUI() {
            const containerLisas = document.getElementById('sunkLisas');
            const containerListradas = document.getElementById('sunkListradas');
            const containerOito = document.getElementById('sunkOito');
            
            containerLisas.innerHTML = '';
            containerListradas.innerHTML = '';
            containerOito.innerHTML = '';

            gameState.sunkBalls.lisas.sort((a, b) => a - b).forEach(number => {
                addBallToContainer(containerLisas, number);
            });

            gameState.sunkBalls.listradas.sort((a, b) => a - b).forEach(number => {
                addBallToContainer(containerListradas, number);
            });

            gameState.sunkBalls.oito.forEach(number => {
                addBallToContainer(containerOito, number, true);
            });
        }
        
        function addBallToContainer(container, number, isEight = false) {
            const ballDiv = document.createElement('div');
            ballDiv.classList.add('sunk-ball');
            if (isEight) ballDiv.classList.add('eight');

            const colorIndex = number - 1; 
            const ballColor = ballColors[colorIndex];
            
            ballDiv.style.backgroundColor = ballColor;
            ballDiv.style.color = number === 8 ? 'white' : 'black';
            ballDiv.textContent = number;
            
            container.appendChild(ballDiv);
        }

        function allBallsStopped() {
            return gameState.balls.every(ball => 
                ball.pocketed || ball.isFalling || (Math.abs(ball.vx) < 0.01 && Math.abs(ball.vy) < 0.01)
            );
        }

        function getOwnBallsRemaining(player) {
            const type = player === 1 ? gameState.player1Type : gameState.player2Type;
            if (!type) return 7; 
            
            const isStripedType = type === 'listrada';
            
            return gameState.balls.filter(b => 
                !b.pocketed && !b.isFalling && b.number > 0 && b.number !== 8 &&
                ((!isStripedType && b.isSolid) || (isStripedType && b.isStriped))
            ).length;
        }

        function checkFoulsAndEndTurn() {
            gameState.shotInProgress = false;
            timer.stop(); 
            
            let isFoul = false;
            let turnContinues = false; 
            let currentType = gameState.currentPlayer === 1 ? gameState.player1Type : gameState.player2Type;
            let ownBallsRemaining = getOwnBallsRemaining(gameState.currentPlayer);
            
            // 1. Falta Branca na Mﾃ｣o 
            if (gameState.sunkBalls.branca.length > 0) {
                showMessage('FALTA! Branca encaﾃｧapada (Branca na Mﾃ｣o).');
                isFoul = true;
            } 
            
            // 2. Nﾃ｣o acertou nenhuma bola
            else if (gameState.firstBallHit === null) {
                showMessage('FALTA! Nﾃ｣o acertou nenhuma bola.');
                isFoul = true;
            } 
            
            // 3. Checar bolas encaﾃｧapadas e acertadas
            let ownBallPocketed = false;
            let opponentBallPocketed = false;
            let eightBallPocketed = false;
            
            gameState.ballsPocketedInShot.forEach(ball => {
                if (ball.isCue) return;
                
                if (ball.isEight) {
                    eightBallPocketed = true;
                } else {
                    const ballType = ball.isStriped ? 'listrada' : 'lisa';
                    
                    if (currentType === null || ballType === currentType) {
                        ownBallPocketed = true;
                    } else {
                        opponentBallPocketed = true;
                    }
                }
            });

            // 4. Acertou a bola errada primeiro
            if (currentType !== null) {
                const targetType = ownBallsRemaining === 0 ? 'oito' : (currentType === 'lisa' ? 'lisa' : 'listrada');
                const hitType = gameState.firstBallHit;
                
                if (hitType !== targetType) {
                    showMessage(`FALTA! Acertou a bola ${hitType} primeiro, mas deveria ser ${targetType}!`);
                    isFoul = true;
                }
            }
            
            // 5. Encaﾃｧapou a bola 8
            if (eightBallPocketed) {
                if (isFoul || ownBallsRemaining > 0) {
                    gameState.gameOver = true;
                    showMessage(`逐 JOGADOR ${gameState.currentPlayer === 1 ? 2 : 1} VENCEU! Bola 8 encaﾃｧapada cedo/com falta!`);
                } else {
                    gameState.gameOver = true;
                    showMessage(`脂 JOGADOR ${gameState.currentPlayer} VENCEU! 脂`);
                }
                timer.stop();
                return; 
            }
            
            // 6. Condiﾃｧﾃ｣o para continuar o turno
            if (!isFoul && (ownBallPocketed || gameState.player1Type === null)) {
                turnContinues = true;
            }
            
            // Aﾃｧﾃ｣o final:
            if (isFoul) {
                gameState.sunkBalls.branca = [0]; 
                switchPlayer(true); 
            } else if (turnContinues) {
                showMessage('Turno continua!');
                timer.start(); 
            } else {
                showMessage('Fim de jogada. Troca de turno.');
                switchPlayer(false); 
            }
            
            gameState.firstBallHit = null;
            gameState.ballsPocketedInShot = [];
        }

        function switchPlayer(foul = false) {
            if (gameState.gameOver) return;
            gameState.currentPlayer = gameState.currentPlayer === 1 ? 2 : 1;
            
            if (foul) {
                 // Reposiciona a branca e ativa o modo "Branca na Mﾃ｣o"
                gameState.whiteBall.pocketed = false;
                gameState.whiteBall.isFalling = false;
                gameState.whiteBall.currentRadius = config.ballRadius;
                gameState.whiteBall.x = HEAD_STRING_X / 2; 
                gameState.whiteBall.y = CANVAS_HEIGHT / 2;
                gameState.whiteBall.vx = 0;
                gameState.whiteBall.vy = 0;
                gameState.isWhiteBallInHand = true; 
                gameState.sunkBalls.branca = []; 
                showMessage(`FALTA! Jogador ${gameState.currentPlayer} no turno (Branca na Mﾃ｣o). Arraste a branca.`);
            } else {
                gameState.isWhiteBallInHand = false;
                showMessage(`Jogador ${gameState.currentPlayer} no turno.`);
                timer.start();
            }

            updateUI();
        }

        function updateUI() {
            timer.updateUI(); 

            const type1 = gameState.player1Type;
            const type2 = gameState.player2Type;
            
            const solidBallsSunk = gameState.sunkBalls.lisas.length;
            const stripedBallsSunk = gameState.sunkBalls.listradas.length;
            
            const solidBallsRemaining = 7 - solidBallsSunk;
            const stripedBallsRemaining = 7 - stripedBallsSunk;

            // ATUALIZAﾃﾃグ DO PAINEL DO JOGADOR
            
            document.getElementById('p1Type').textContent = type1 ? 
                (type1 === 'lisa' ? 'Lisas' : 'Listradas') : 'Sem Tipo';
            document.getElementById('p2Type').textContent = type2 ? 
                (type2 === 'lisa' ? 'Lisas' : 'Listradas') : 'Sem Tipo';
                
            document.getElementById('p1Balls').textContent = type1 === 'lisa' ? 
                (solidBallsRemaining <= 0 ? '8 PENDENTE' : solidBallsRemaining) : 
                (type1 === 'listrada' ? (stripedBallsRemaining <= 0 ? '8 PENDENTE' : stripedBallsRemaining) : 7);
                
            document.getElementById('p2Balls').textContent = type2 === 'lisa' ? 
                (solidBallsRemaining <= 0 ? '8 PENDENTE' : solidBallsRemaining) : 
                (type2 === 'listrada' ? (stripedBallsRemaining <= 0 ? '8 PENDENTE' : stripedBallsRemaining) : 7);
            
            const effX = config.effectPower.x;
            const effY = config.effectPower.y;
            let display = 'Centro';
            
            if (effY > 0.6) display = 'Superior';
            else if (effY < -0.6) display = 'Inferior';
            
            if (effX > 0.6) display = (display === 'Centro' ? '' : display + ' ') + 'Direita';
            else if (effX < -0.6) display = (display === 'Centro' ? '' : display + ' ') + 'Esquerda';

            document.getElementById('effectDisplay').textContent = display.trim() || 'Centro';
            
            // ATUALIZAﾃﾃグ DE COR E TEXTO DO EFEITO NO CARD
            const activeCard = document.getElementById(`player${gameState.currentPlayer}Card`);
            const neonColor = activeCard.style.getPropertyValue('--neon-color');
            
            if (gameState.currentPlayer === 1) {
                document.getElementById('p1Effect').textContent = display.trim() || 'Centro';
                document.getElementById('p1Effect').style.setProperty('color', neonColor);
            } else {
                document.getElementById('p2Effect').textContent = display.trim() || 'Centro';
                document.getElementById('p2Effect').style.setProperty('color', neonColor);
            }
        }

        function showMessage(msg) {
            document.getElementById('message').textContent = msg;
            setTimeout(() => {
                if (!gameState.gameOver && !gameState.shotInProgress && !gameState.isWhiteBallInHand) {
                    document.getElementById('message').textContent = '';
                }
            }, 3000);
        }
        
        function initGame() {
            gameState.balls = [];
            gameState.currentPlayer = 1;
            gameState.player1Type = null;
            gameState.player2Type = null;
            gameState.gameOver = false;
            gameState.shotInProgress = false;
            gameState.firstBallHit = null;
            gameState.ballsPocketedInShot = [];
            gameState.sunkBalls = { lisas: [], listradas: [], oito: [], branca: [] };
            gameState.isWhiteBallInHand = false;
            
            config.effectPower = {x: 0, y: 0};
            
            timer.stop();
            timer.timeRemaining = MAX_TIME;

            gameState.whiteBall = new Ball(HEAD_STRING_X / 2, CANVAS_HEIGHT / 2, 0); 
            gameState.balls.push(gameState.whiteBall);

            const startX = CANVAS_WIDTH - 200;
            const startY = CANVAS_HEIGHT / 2;
            const spacing = config.ballRadius * 2 + 1;
            
            const pyramidBalls = [
                1, 
                15, 2, 
                14, 8, 13, 
                3, 12, 4, 11, 
                5, 10, 6, 9, 7
            ];
            let ballIndex = 0;


            for (let row = 0; row < 5; row++) {
                for (let col = 0; col < row + 1; col++) { // Corrigido o loop para 5 linhas
                    const x = startX + row * spacing * Math.sqrt(3) / 2;
                    const y = startY + (col - row / 2) * spacing;
                    
                    const number = pyramidBalls[ballIndex++];
                    gameState.balls.push(new Ball(x, y, number));
                }
            }
            
            document.getElementById('effectMarker').style.left = '50%';
            document.getElementById('effectMarker').style.top = '50%';
            config.effectPower = {x: 0, y: 0};
            
            updateSunkBallsUI(); 
            updateUI();
            timer.start(); 
            showMessage('Arraste o mouse/toque ao redor da bola branca para mirar.');
        }

        function drawDiamondShape(x, y, size) {
            ctx.beginPath();
            ctx.moveTo(x, y - size);
            ctx.lineTo(x + size / 2, y);
            ctx.lineTo(x, y + size);
            ctx.lineTo(x - size / 2, y);
            ctx.closePath();
            ctx.fill();
        }

        function drawDiamonds(margin) {
            ctx.fillStyle = '#FFD700'; 
            const innerW = CANVAS_WIDTH - 2 * margin;
            const innerH = CANVAS_HEIGHT - 2 * margin;
            const diamondSize = 4;

            const railYTop = margin / 2;
            for (let i = 1; i < 8; i += 2) { 
                const x = margin + (innerW / 8) * i;
                if (i !== 3 && i !== 5) { 
                     drawDiamondShape(x, railYTop, diamondSize);
                }
            }

            const railYBottom = CANVAS_HEIGHT - margin / 2;
            for (let i = 1; i < 8; i += 2) {
                const x = margin + (innerW / 8) * i;
                 if (i !== 3 && i !== 5) {
                    drawDiamondShape(x, railYBottom, diamondSize);
                }
            }

            const railXLeft = margin / 2;
            for (let i = 1; i < 4; i += 2) {
                const y = margin + (innerH / 4) * i;
                drawDiamondShape(railXLeft, y, diamondSize);
            }

            const railXRight = CANVAS_WIDTH - margin / 2;
            for (let i = 1; i < 4; i += 2) {
                const y = margin + (innerH / 4) * i;
                drawDiamondShape(railXRight, y, diamondSize);
            }
        }

        function drawTable() {
            
            // Desenho dos Trilhos (Rail)
            const railGradient = ctx.createLinearGradient(0, 0, 0, CANVAS_HEIGHT);
            railGradient.addColorStop(0, '#A0522D'); 
            railGradient.addColorStop(0.3, '#8B4513'); 
            railGradient.addColorStop(0.7, '#D2691E'); 
            railGradient.addColorStop(1, '#8B4513'); 
            ctx.fillStyle = railGradient;
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            drawDiamonds(MARGIN);

            // Desenho do Feltro
            const feltGradient = ctx.createRadialGradient(CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2, 0, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2, 500);
            feltGradient.addColorStop(0, '#32CD32'); 
            feltGradient.addColorStop(0.3, '#228B22'); 
            feltGradient.addColorStop(0.7, '#006400'); 
            feltGradient.addColorStop(1, '#004d00'); 
            ctx.fillStyle = feltGradient;
            
            ctx.save();
            ctx.shadowColor = 'rgba(0,0,0,0.7)';
            ctx.shadowBlur = 25;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;

            ctx.fillRect(MARGIN, MARGIN, CANVAS_WIDTH - 2 * MARGIN, CANVAS_HEIGHT - 2 * MARGIN);
            ctx.restore();

            ctx.strokeStyle = 'rgba(255,255,255,0.2)';
            ctx.lineWidth = 2;
            ctx.strokeRect(MARGIN, MARGIN, CANVAS_WIDTH - 2 * MARGIN, CANVAS_HEIGHT - 2 * MARGIN);

            // Linha de Falta (Head String)
            ctx.strokeStyle = 'rgba(255,255,255,0.4)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(HEAD_STRING_X, MARGIN);
            ctx.lineTo(HEAD_STRING_X, CANVAS_HEIGHT - MARGIN);
            ctx.stroke();

            // Pockets
            pockets.forEach(pocket => {
                const pocketGrad = ctx.createRadialGradient(pocket.x, pocket.y, 0, pocket.x, pocket.y, config.pocketRadius);
                pocketGrad.addColorStop(0, '#222222');
                pocketGrad.addColorStop(0.7, '#000000');
                pocketGrad.addColorStop(1, '#111111');
                ctx.fillStyle = pocketGrad;
                
                ctx.save();
                ctx.shadowColor = 'rgba(0,0,0,1)';
                ctx.shadowBlur = 15;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 5;

                ctx.beginPath();
                ctx.arc(pocket.x, pocket.y, config.pocketRadius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore(); 

                ctx.strokeStyle = '#A0522D'; 
                ctx.lineWidth = 4;
                ctx.stroke();
            });
        }
        
        // --- Lﾃｳgica de Mira Aprimorada ---

        function isTargetBall(ball) {
            if (ball.isCue || ball.isEight || gameState.player1Type === null) return true;

            const currentPlayerType = gameState.currentPlayer === 1 ? gameState.player1Type : gameState.player2Type;
            const ballType = ball.isStriped ? 'listrada' : 'lisa';
            
            if (getOwnBallsRemaining(gameState.currentPlayer) === 0) {
                return ball.isEight;
            }
            
            return ballType === currentPlayerType;
        }

        /**
         * Desenha o caminho de mira com estilo tracejado/pontilhado e sombra.
         * @param {number} startX - Posiﾃｧﾃ｣o X inicial.
         * @param {number} startY - Posiﾃｧﾃ｣o Y inicial.
         * @param {number} angle - ﾃＯgulo de direﾃｧﾃ｣o.
         * @param {number} maxDist - Distﾃ｢ncia mﾃ｡xima a ser desenhada.
         * @param {string} color - Cor da linha.
         * @param {Array} dash - Padrﾃ｣o de tracejado ([on, off]).
         */
        function drawAimPath(startX, startY, angle, maxDist, color, dash) {
            ctx.save();
            ctx.strokeStyle = color; 
            ctx.lineWidth = 3; 
            ctx.setLineDash(dash); 
            ctx.lineCap = 'round';
            
            ctx.shadowColor = color;
            ctx.shadowBlur = 5;

            ctx.beginPath();
            ctx.moveTo(startX, startY);
            
            const endX = startX + Math.cos(angle) * maxDist;
            const endY = startY + Math.sin(angle) * maxDist;

            ctx.lineTo(endX, endY);
            ctx.stroke();
            ctx.restore();
        }

        // Cﾃ｡lculo preciso do ponto de contato
        function getCueBallCollisionInfo(white, angle) {
            let minDistance = 1600;
            let firstHitBall = null;
            let hitPointX = null;
            let hitPointY = null;
            let projDistance = 0;
            let angleDiff = 0;
            let distToCenter = 0;
            
            for (const ball of gameState.balls) {
                if (ball.pocketed || ball.isCue || ball.isFalling) continue;

                const dx = ball.x - white.x;
                const dy = ball.y - white.y;
                distToCenter = Math.sqrt(dx * dx + dy * dy);

                const angleToCenter = Math.atan2(dy, dx);
                angleDiff = angleToCenter - angle;
                
                while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;

                const perpDist = distToCenter * Math.abs(Math.sin(angleDiff));
                
                const totalRadius = ball.radius + white.radius; 

                if (perpDist < totalRadius && Math.cos(angleDiff) > 0) {
                    
                    projDistance = distToCenter * Math.cos(angleDiff);
                    const hitDistance = projDistance - Math.sqrt(totalRadius ** 2 - perpDist ** 2);
                    
                    if (hitDistance > 0 && hitDistance < minDistance) {
                        minDistance = hitDistance;
                        firstHitBall = ball;
                        hitPointX = white.x + Math.cos(angle) * hitDistance;
                        hitPointY = white.y + Math.sin(angle) * hitDistance;
                    }
                }
            }
            return { firstHitBall, minDistance, hitPointX, hitPointY, projDistance, angleDiff, distToCenter };
        }

        function isCueBallPlacementValid(x, y) {
            const r = config.ballRadius;
            const minX = MARGIN + r;
            const maxX = HEAD_STRING_X - r;
            const minY = MARGIN + r;
            const maxY = CANVAS_HEIGHT - MARGIN - r;

            if (x < minX || x > maxX || y < minY || y > maxY) {
                return false;
            }

            for (const ball of gameState.balls) {
                if (ball.pocketed || ball.isCue || ball.isFalling) continue;

                const dx = ball.x - x;
                const dy = ball.y - y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < r + ball.radius - 0.5) { 
                    return false;
                }
            }
            return true;
        }


        // FUNﾃﾃグ drawCue MELHORADA COM MIRA SECUNDﾃヽIA (MAIS REALISTA)
        function drawCue() {
            if (gameState.shotInProgress || gameState.gameOver || gameState.isWhiteBallInHand) return;

            const white = gameState.whiteBall;
            const angle = gameState.cue.angle;
            const power = gameState.cue.power;
            const powerPercent = power / config.maxPower;
            
            const { firstHitBall, minDistance, projDistance, angleDiff, distToCenter } = getCueBallCollisionInfo(white, angle);
            
            let aimColor = 'rgba(255, 255, 255, 0.8)'; // Branco (padrﾃ｣o)
            let aimMaxDist = 1600; 
            
            // 1. Mira Principal (da Branca)
            if (firstHitBall) {
                
                if (isTargetBall(firstHitBall)) {
                    aimColor = 'rgba(0, 255, 0, 0.8)'; // Verde (Alvo Correto)
                } else {
                    aimColor = 'rgba(255, 0, 0, 0.8)'; // Vermelho (Alvo Errado)
                }
                
                aimMaxDist = minDistance; 
                
                // Desenha a mira principal (atﾃｩ o ponto de colisﾃ｣o)
                drawAimPath(white.x, white.y, angle, minDistance, aimColor, [8, 8]);

                // Cﾃ´CULO DA TRAJETﾃ迭IA REFLETIDA DA BRANCA
                const targetAngle = angle + angleDiff; // angleToCenter
                
                // Vetor de direﾃｧﾃ｣o incidente (unitﾃ｡rio)
                const vx = Math.cos(angle);
                const vy = Math.sin(angle);
                
                // Normal unitﾃ｡ria (ao longo dos centros)
                const nx = Math.cos(targetAngle);
                const ny = Math.sin(targetAngle);
                
                // Tangente unitﾃ｡ria (rotacionada 90 graus CCW)
                const tx = -ny;
                const ty = nx;
                
                // Componente tangencial: dot(v, t)
                const dot_t = vx * tx + vy * ty;
                
                // Velocidade refletida: v_t = dot_t * t
                const v_tx = dot_t * tx;
                const v_ty = dot_t * ty;
                
                // ﾃＯgulo refletido
                const reflectedAngle = Math.atan2(v_ty, v_tx);
                
                // Posiﾃｧﾃ｣o do centro da branca no impacto
                const whiteImpactX = white.x + vx * projDistance;
                const whiteImpactY = white.y + vy * projDistance;
                
                // Desenha a mira refletida (trajetﾃｳria da branca apﾃｳs colisﾃ｣o)
                const reflectedPathLength = 150;
                drawAimPath(whiteImpactX, whiteImpactY, reflectedAngle, reflectedPathLength, aimColor, [8, 8]);

                // Desenha a "imagem fantasma" no ponto de colisﾃ｣o (para mira de "meia bola")
                ctx.save();
                ctx.globalAlpha = 0.5;
                ctx.fillStyle = aimColor;
                ctx.beginPath();
                ctx.arc(
                    white.x + Math.cos(angle) * minDistance,
                    white.y + Math.sin(angle) * minDistance,
                    white.radius, 0, Math.PI * 2
                );
                ctx.fill();
                ctx.restore();

            } else {
                drawAimPath(white.x, white.y, angle, aimMaxDist, aimColor, [8, 8]);
            }
            
            
            // BARRA DE PODER CIRCULAR AO REDOR DA BOLA BRANCA
            
            if (gameState.isDragging && power > 0) {
                ctx.save();
                ctx.translate(white.x, white.y);
                
                // Cﾃｭrculo de fundo
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(0, 0, white.radius + 5, 0, Math.PI * 2);
                ctx.stroke();

                // Arco de progresso
                const startAngle = -Math.PI / 2;
                const endAngle = startAngle + (Math.PI * 2 * powerPercent);
                
                const powerGradient = ctx.createLinearGradient(0, -(white.radius + 5), 0, white.radius + 5);
                powerGradient.addColorStop(0, '#53A8B6');
                powerGradient.addColorStop(1, '#00A896');
                
                ctx.strokeStyle = powerGradient;
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(0, 0, white.radius + 5, startAngle, endAngle);
                ctx.stroke();
                
                ctx.restore();
            }
            
            // Desenha o taco
            const cueDistance = 30 + power * 2; 
            const cueLength = 200;
            
            const cueX = white.x - Math.cos(angle) * cueDistance;
            const cueY = white.y - Math.sin(angle) * cueDistance;
            
            const tipX = cueX - Math.cos(angle) * cueLength;
            const tipY = cueY - Math.sin(angle) * cueLength;

            ctx.save();
            ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
            ctx.shadowBlur = 8;
            ctx.shadowOffsetX = 3;
            ctx.shadowOffsetY = 3;

            ctx.strokeStyle = '#A0522D';
            ctx.lineWidth = 8;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(cueX, cueY);
            ctx.lineTo(tipX, tipY);
            ctx.stroke();

            ctx.strokeStyle = '#4169E1';
            ctx.lineWidth = 5;
            ctx.beginPath();
            ctx.moveTo(cueX, cueY);
            ctx.lineTo(
                cueX - Math.cos(angle) * 8,
                cueY - Math.sin(angle) * 8
            );
            ctx.stroke();

            ctx.restore();

            // Desenha o marcador de Efeito na Bola Branca (VISUAL MELHORADO)
            const effectX = config.effectPower.x;
            const effectY = config.effectPower.y;
            
            ctx.save();
            ctx.translate(white.x, white.y);
            
            const offsetX = effectX * (white.radius * 0.7);
            const offsetY = effectY * (white.radius * 0.7);
            const effectSize = 5;
            
            // Gradiente radial para o marcador
            const gradient = ctx.createRadialGradient(offsetX, offsetY, 0, offsetX, offsetY, effectSize);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(0.5, 'rgba(255, 50, 50, 1)');
            gradient.addColorStop(1, 'rgba(255, 50, 50, 0)');
            
            ctx.fillStyle = gradient;
            ctx.shadowColor = 'rgba(255, 50, 50, 1)';
            ctx.shadowBlur = 20;
            
            ctx.beginPath();
            ctx.arc(offsetX, offsetY, effectSize, 0, Math.PI * 2);
            ctx.fill();
            
            // Adiciona um anel externo para mais destaque
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(offsetX, offsetY, effectSize + 2, 0, Math.PI * 2);
            ctx.stroke();
            
            ctx.restore();
        }
        
        function getPointerPos(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = CANVAS_WIDTH / rect.width;
            const scaleY = CANVAS_HEIGHT / rect.height;
            
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            
            return {
                x: (clientX - rect.left) * scaleX,
                y: (clientY - rect.top) * scaleY
            };
        }

        function handleStart(e) {
            e.preventDefault();
            if (gameState.gameOver) return;

            const pos = getPointerPos(e);
            const white = gameState.whiteBall;

            const dx = pos.x - white.x;
            const dy = pos.y - white.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            // 1. Prioridade: Arrastar a bola branca (Branca na Mﾃ｣o)
            if (gameState.isWhiteBallInHand && dist < white.radius * 2) {
                gameState.isWhiteBallDragging = true;
                gameState.cue.visible = false;
                timer.stop();
                return; 
            }
            
            // 2. Segunda Prioridade: Iniciar a mira/tacada
            if (!gameState.isWhiteBallInHand && !gameState.shotInProgress && allBallsStopped()) { 
                gameState.cue.x = pos.x;
                gameState.cue.y = pos.y;
                gameState.isDragging = true;
                gameState.cue.visible = true;
                gameState.cue.power = 0;
            }
        }

        function handleMove(e) {
            e.preventDefault();
            const pos = getPointerPos(e);
            const white = gameState.whiteBall;

            // Arrastando a bola branca (Branca na Mﾃ｣o)
            if (gameState.isWhiteBallDragging) {
                const r = white.radius;
                const minX = MARGIN + r;
                const maxX = HEAD_STRING_X - r;
                const minY = MARGIN + r;
                const maxY = CANVAS_HEIGHT - MARGIN - r;

                white.x = Math.max(minX, Math.min(pos.x, maxX));
                white.y = Math.max(minY, Math.min(pos.y, maxY));
                
                showMessage('Branca na Mﾃ｣o. Solte para confirmar a posiﾃｧﾃ｣o.');
                
                return;
            }

            // Mira/Arrasto do Taco
            if (gameState.isDragging) {
                const dx = white.x - pos.x; 
                const dy = white.y - pos.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                gameState.cue.angle = Math.atan2(dy, dx); 
                gameState.cue.power = Math.min(distance / 5, config.maxPower);
                
                // Atualiza a barra de forﾃｧa no modal de efeito (se estiver aberto)
                document.getElementById('powerFill').style.width = `${(gameState.cue.power / config.maxPower) * 100}%`;

            } else if (allBallsStopped() && !gameState.gameOver && !gameState.isWhiteBallInHand) {
                // Apenas mira (sem arrastar)
                const dx = white.x - pos.x;
                const dy = white.y - pos.y;
                gameState.cue.angle = Math.atan2(dy, dx);
                gameState.cue.visible = true;
                gameState.cue.power = 0;
            }
        }

        function handleEnd(e) {
            e.preventDefault();
            
            // 1. Fim do Arrastar Branca na Mﾃ｣o
            if (gameState.isWhiteBallDragging) {
                gameState.isWhiteBallDragging = false;
                
                if (isCueBallPlacementValid(gameState.whiteBall.x, gameState.whiteBall.y)) {
                    gameState.isWhiteBallInHand = false;
                    showMessage('Posiﾃｧﾃ｣o da Branca confirmada. Hora de mirar!');
                    timer.start();
                } else {
                    showMessage('POSIﾃﾃグ INVﾃ´IDA! A branca nﾃ｣o pode tocar em outra bola ou sair do limite. Arraste novamente.');
                    gameState.isWhiteBallInHand = true; 
                    if (!isCueBallPlacementValid(gameState.whiteBall.x, gameState.whiteBall.y)) {
                         gameState.whiteBall.x = HEAD_STRING_X / 2; 
                         gameState.whiteBall.y = CANVAS_HEIGHT / 2;
                    }
                }
                return;
            }

            // 2. Fim do Arrasto do Taco (Tacada)
            if (gameState.isDragging && allBallsStopped() && gameState.cue.power > 0.5) {
                const white = gameState.whiteBall;
                
                const baseVx = Math.cos(gameState.cue.angle) * gameState.cue.power;
                const baseVy = Math.sin(gameState.cue.angle) * gameState.cue.power;

                // Efeito de Translaﾃｧﾃ｣o (Sidespin e Topspin/Backspin)
                const effectFactor = 0.5; 
                const sideSpinVx = Math.sin(gameState.cue.angle) * config.effectPower.x * effectFactor * gameState.cue.power / config.maxPower;
                const sideSpinVy = -Math.cos(gameState.cue.angle) * config.effectPower.x * effectFactor * gameState.cue.power / config.maxPower;
                
                const topBackFactor = 0.1;
                const topBackVx = Math.cos(gameState.cue.angle) * config.effectPower.y * topBackFactor * gameState.cue.power / config.maxPower;
                const topBackVy = Math.sin(gameState.cue.angle) * config.effectPower.y * topBackFactor * gameState.cue.power / config.maxPower;
                
                white.vx = baseVx + sideSpinVx + topBackVx;
                white.vy = baseVy + sideSpinVy + topBackVy;

                // Efeito de Rotaﾃｧﾃ｣o (para visual de giro)
                const rotationFactor = 0.5; // Ajuste a magnitude do giro
                white.rotationAngle += config.effectPower.x * rotationFactor;
                
                gameState.shotInProgress = true;
                gameState.cue.visible = false;
                timer.stop(); 
                
                const checkInterval = setInterval(() => {
                    if (allBallsStopped()) {
                        clearInterval(checkInterval);
                        checkFoulsAndEndTurn();
                    }
                }, 100);

            }
            gameState.isDragging = false;
            document.getElementById('powerFill').style.width = '0%';
        }

        canvas.addEventListener('mousedown', handleStart);
        canvas.addEventListener('mousemove', handleMove);
        canvas.addEventListener('mouseup', handleEnd);

        canvas.addEventListener('touchstart', handleStart);
        canvas.addEventListener('touchmove', handleMove);
        canvas.addEventListener('touchend', handleEnd);

        document.getElementById('resetBtn').addEventListener('click', initGame);

        const effectModal = document.getElementById('effectModal');
        const effectBoard = document.getElementById('effectBoard');
        const effectMarker = document.getElementById('effectMarker');

        document.getElementById('effectBtn').addEventListener('click', () => {
            effectModal.style.display = 'flex';
            // Garante que a barra de forﾃｧa reflita o power atual (se nﾃ｣o houver tacada)
            document.getElementById('powerFill').style.width = `${(gameState.cue.power / config.maxPower) * 100}%`;
        });

        document.getElementById('closeEffectBtn').addEventListener('click', () => {
            effectModal.style.display = 'none';
        });

        function updateEffectFromPointer(e) {
            e.preventDefault();
            const rect = effectBoard.getBoundingClientRect();
            
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            let x = clientX - rect.left - rect.width / 2;
            let y = clientY - rect.top - rect.height / 2;

            const dist = Math.sqrt(x * x + y * y);
            const radius = rect.width / 2;

            if (dist > radius) {
                const angle = Math.atan2(y, x);
                x = Math.cos(angle) * radius;
                y = Math.sin(angle) * radius;
            }

            effectMarker.style.left = `${(rect.width / 2) + x}px`;
            effectMarker.style.top = `${(rect.height / 2) + y}px`;

            // Normaliza o efeito para um valor entre -1 e 1
            config.effectPower.x = x / radius;
            config.effectPower.y = y / radius; 

            updateUI();
        }
        
        let isEffectDragging = false;
        
        effectBoard.addEventListener('mousedown', (e) => {
            isEffectDragging = true;
            updateEffectFromPointer(e);
        });
        effectBoard.addEventListener('mousemove', (e) => {
            if (isEffectDragging) updateEffectFromPointer(e);
        });
        window.addEventListener('mouseup', () => { 
            isEffectDragging = false;
        });

        effectBoard.addEventListener('touchstart', (e) => {
            isEffectDragging = true;
            updateEffectFromPointer(e);
        });
        effectBoard.addEventListener('touchmove', (e) => {
            if (isEffectDragging) updateEffectFromPointer(e);
        });
        window.addEventListener('touchend', () => {
            isEffectDragging = false;
        });

        function gameLoop() {
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            drawTable();

            if (!gameState.shotInProgress && allBallsStopped()) {
                if (gameState.isWhiteBallInHand) {
                    // Desenha o cﾃｭrculo de validaﾃｧﾃ｣o para Branca na Mﾃ｣o
                    ctx.save();
                    const isValid = isCueBallPlacementValid(gameState.whiteBall.x, gameState.whiteBall.y);
                    ctx.strokeStyle = isValid ? 'rgba(0, 255, 0, 0.8)' : 'rgba(255, 0, 0, 0.8)';
                    ctx.lineWidth = 4;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.arc(gameState.whiteBall.x, gameState.whiteBall.y, gameState.whiteBall.radius * 2, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                } else {
                    drawCue(); 
                }
            }

            gameState.balls.forEach(ball => ball.update());
            handleCollisions();
            gameState.balls.forEach(ball => ball.draw());

            requestAnimationFrame(gameLoop);
        }

        initGame();
        gameLoop();
    </script>
</body>
</html>
