<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Pool 3D - Ultimate AI & Power Ring</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --primary-color: #00f3ff; 
            --bg-color: #050505;
            --panel-bg: rgba(10, 15, 20, 0.95);
            --danger-color: #ff3333;
            --win-color: #ffd700;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; -webkit-user-select: none; }
        
        body {
            background-color: var(--bg-color);
            background-image: 
                radial-gradient(circle at 50% 50%, #151515, #000),
                linear-gradient(0deg, rgba(0, 243, 255, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 243, 255, 0.03) 1px, transparent 1px);
            background-size: 100% 100%, 40px 40px, 40px 40px;
            font-family: 'Orbitron', sans-serif;
            overflow: hidden;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
        }

        .game-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            transform: scale(1);
            transition: transform 0.3s;
        }

        /* --- HUD SUPERIOR --- */
        .hud-panel {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 680px;
            background: var(--panel-bg);
            padding: 12px 25px;
            border-radius: 16px;
            border: 1px solid #333;
            border-bottom: 3px solid var(--primary-color);
            box-shadow: 0 0 25px rgba(0, 243, 255, 0.15);
            position: relative;
            z-index: 10;
        }

        .player-section {
            display: flex;
            align-items: center;
            gap: 15px;
            opacity: 0.4;
            transition: 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            filter: grayscale(100%);
        }
        .player-section.active-turn { 
            opacity: 1; 
            transform: scale(1.05); 
            filter: grayscale(0%);
        }

        .avatar-container {
            position: relative;
            width: 64px; height: 64px;
            display: flex; align-items: center; justify-content: center;
        }
        .timer-svg {
            position: absolute; top: 0; left: 0;
            width: 64px; height: 64px;
            transform: rotate(-90deg);
        }
        .timer-circle-bg { fill: none; stroke: #222; stroke-width: 5; }
        .timer-circle-fg { 
            fill: none; stroke: var(--primary-color); stroke-width: 5; 
            stroke-dasharray: 175; 
            stroke-dashoffset: 0;
            transition: stroke-dashoffset 1s linear, stroke 0.3s;
            stroke-linecap: round;
        }

        .avatar-img {
            width: 50px; height: 50px;
            border-radius: 50%;
            background-size: cover; background-position: center;
            border: 2px solid #fff;
            z-index: 2;
            box-shadow: 0 0 10px rgba(255,255,255,0.3);
        }

        .p-info { display: flex; flex-direction: column; }
        .p-name { font-weight: 900; font-size: 14px; letter-spacing: 1px; color: #fff; text-shadow: 0 0 5px var(--primary-color); }
        .p-type { font-size: 10px; color: #aaa; margin-top: 3px; font-weight: bold; }
        
        /* CONTADOR DE VIT칍RIAS */
        .win-counter {
            font-size: 10px;
            color: var(--win-color);
            font-weight: bold;
            margin-top: 4px;
            text-shadow: 0 0 5px rgba(255, 215, 0, 0.5);
        }

        .score-dots { display: flex; gap: 5px; margin-top: 6px; }
        .dot { width: 8px; height: 8px; background: #222; border-radius: 50%; border: 1px solid #444; transition: 0.3s; }
        .dot.active { background: var(--primary-color); border-color: #fff; box-shadow: 0 0 8px var(--primary-color); transform: scale(1.2); }

        /* --- MESA DE JOGO --- */
        .main-area {
            display: flex;
            flex-direction: row;
            align-items: flex-start;
            gap: 20px;
        }

        #game-container {
            position: relative;
            width: 680px; height: 390px;
            padding: 30px;
            background: #0b0b0b;
            border-radius: 35px;
            box-shadow: 
                0 0 0 2px #222, 
                0 20px 50px rgba(0,0,0,0.8), 
                inset 0 0 60px rgba(0,0,0,0.9);
        }

        #game-inner {
            position: relative; width: 100%; height: 100%;
            border-radius: 16px; overflow: hidden; background: #000; 
            border: 4px solid #1a1a1a;
            box-shadow: inset 0 0 20px #000;
        }
        
        canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        #three-canvas { pointer-events: none; z-index: 2; }
        #fx-canvas { pointer-events: none; z-index: 3; } /* UI Effects, Aim lines */
        #input-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 100; cursor: crosshair; }

        /* --- CONTROLES LATERAIS --- */
        .side-controls {
            display: flex; flex-direction: column; gap: 12px; padding: 15px;
            background: var(--panel-bg); border-radius: 16px; border: 1px solid #333;
            height: 390px; justify-content: center; align-items: center; position: relative;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        .btn-neon {
            width: 60px; height: 60px; background: rgba(255,255,255,0.02);
            border: 1px solid rgba(255,255,255,0.1); border-radius: 12px;
            cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: var(--primary-color); transition: all 0.2s; position: relative; overflow: hidden;
        }
        .btn-neon:hover { background: rgba(0, 243, 255, 0.1); border-color: var(--primary-color); box-shadow: 0 0 15px var(--primary-color); transform: translateY(-2px); }
        .btn-neon:active { transform: scale(0.95); }
        .btn-neon svg { width: 22px; height: 22px; fill: currentColor; margin-bottom: 4px; }
        .btn-neon span { font-size: 8px; font-weight: 900; text-transform: uppercase; letter-spacing: 1px; }

        #spin-popover {
            position: absolute; top: 10px; right: 90px;
            width: 120px; height: 140px; background: rgba(10, 12, 16, 0.98);
            border: 1px solid var(--primary-color); border-radius: 12px;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            opacity: 0; visibility: hidden; transition: 0.3s; z-index: 200;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
            transform: scale(0.8);
        }
        #spin-popover.visible { opacity: 1; visibility: visible; transform: scale(1); right: 80px;}
        .spin-ball { width: 80px; height: 80px; background: radial-gradient(circle at 35% 35%, #fff, #ddd, #888); border-radius: 50%; margin-top: 8px; cursor: pointer; position: relative; box-shadow: inset 0 -5px 10px rgba(0,0,0,0.5); }
        #spin-dot { width: 10px; height: 10px; background: #ff3333; border-radius: 50%; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); box-shadow: 0 0 5px #ff3333; pointer-events: none;}
        #bot-spin-dot { width: 10px; height: 10px; background: #33ff33; border-radius: 50%; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); box-shadow: 0 0 5px #33ff33; pointer-events: none; opacity: 0;}

        /* TOAST NOTIFICATIONS AJUSTADO PARA SER MENOR */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 150; pointer-events: none; display: flex; justify-content: center; align-items: flex-start; flex-direction: column; padding-top: 150px;}
        .toast {
            background: rgba(0,0,0,0.9); color: #fff; padding: 8px 20px; /* Reduzido o padding */
            border: 1px solid var(--primary-color); border-radius: 50px;
            font-size: 16px; /* Reduzido o font-size */
            font-weight: 900; text-transform: uppercase; letter-spacing: 2px;
            opacity: 0; transition: 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); transform: scale(0.5);
            box-shadow: 0 0 20px var(--primary-color), inset 0 0 10px rgba(0, 243, 255, 0.2); /* Reduzido o shadow */
            text-shadow: 0 0 5px var(--primary-color);
            text-align: center; margin-bottom: 10px;
            align-self: center; /* Centraliza */
        }
        .toast.show { opacity: 1; transform: scale(1); }
        .toast.bad { border-color: #ff3333; box-shadow: 0 0 20px #ff3333; text-shadow: 0 0 5px #ff3333; color: #ff3333; }

        /* Chat Bubbles */
        .chat-bubble {
            position: absolute; top: 60px; left: 0;
            background: #fff; color: #000; padding: 8px 14px;
            border-radius: 16px; font-size: 20px;
            opacity: 0; transform: translateY(10px); transition: 0.3s;
            z-index: 20; box-shadow: 0 5px 15px rgba(0,0,0,0.5); pointer-events: none;
        }
        .chat-bubble.show { opacity: 1; transform: translateY(0); }
        #p1-bubble { left: 10px; border-top-left-radius: 0; }
        #p2-bubble { right: 10px; left: auto; border-top-right-radius: 0; }

    </style>
</head>
<body>

    <div class="game-wrapper">
        <div class="hud-panel">
            
            <div class="player-section active-turn" id="p1-section">
                <div class="avatar-container">
                    <svg class="timer-svg">
                        <circle class="timer-circle-bg" cx="32" cy="32" r="28"></circle>
                        <circle id="p1-timer" class="timer-circle-fg" cx="32" cy="32" r="28"></circle>
                    </svg>
                    <div class="avatar-img" style="background-image: url('https://api.dicebear.com/7.x/avataaars/svg?seed=King');"></div>
                </div>
                <div class="p-info">
                    <span class="p-name">VOC칅</span>
                    <span class="p-type" id="p1-type-label">--</span>
                    <div class="win-counter" id="p1-wins-display">VIT칍RIAS: 0</div>
                    <div class="score-dots" id="p1-score"></div>
                </div>
                <div class="chat-bubble" id="p1-bubble">游땙</div>
            </div>

            <div style="font-size: 24px; font-weight:900; opacity: 0.2; font-style: italic;">VS</div>

            <div class="player-section" id="p2-section">
                <div class="chat-bubble" id="p2-bubble">游뱄</div>
                <div class="p-info" style="align-items: flex-end;">
                    <span class="p-name">SKYNET AI</span>
                    <span class="p-type" id="p2-type-label">--</span>
                    <div class="win-counter" id="p2-wins-display">VIT칍RIAS: 0</div>
                    <div class="score-dots" id="p2-score"></div>
                </div>
                <div class="avatar-container">
                    <svg class="timer-svg">
                        <circle class="timer-circle-bg" cx="32" cy="32" r="28"></circle>
                        <circle id="p2-timer" class="timer-circle-fg" cx="32" cy="32" r="28"></circle>
                    </svg>
                    <div class="avatar-img" style="background-image: url('https://api.dicebear.com/7.x/bottts/svg?seed=Terminator');"></div>
                </div>
            </div>
        </div>

        <div class="main-area">
            <div id="game-container">
                <div id="game-inner">
                    <canvas id="table-canvas" width="620" height="330"></canvas>
                    <div id="input-layer"></div>
                    <canvas id="fx-canvas" width="620" height="330"></canvas>
                </div>
                <div id="ui-layer">
                    <div id="game-toast" class="toast"></div>
                </div>
            </div>

            <div class="side-controls">
                <div id="spin-popover">
                    <span style="font-size:9px; color:#aaa; margin-bottom:5px;">PONTO DE BATIDA</span>
                    <div class="spin-ball" id="spin-control">
                        <div id="spin-dot"></div>
                        <div id="bot-spin-dot"></div>

                        <div style="position:absolute; top:50%; left:0; width:100%; height:1px; background:rgba(0,0,0,0.2);"></div>
                        <div style="position:absolute; top:0; left:50%; width:1px; height:100%; background:rgba(0,0,0,0.2);"></div>
                    </div>
                </div>

                <button class="btn-neon" onclick="toggleSpinMenu()">
                    <svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/><circle cx="12" cy="12" r="3"/></svg>
                    <span>Efeito</span>
                </button>

                <button class="btn-neon" onclick="cycleTheme()">
                    <svg viewBox="0 0 24 24"><path d="M12 3c-4.97 0-9 4.03-9 9s4.03 9 9 9c.83 0 1.5-.67 1.5-1.5 0-.39-.15-.74-.39-1.01-.23-.26-.38-.61-.38-.99 0-.83.67-1.5 1.5-1.5H16c2.76 0 5-2.24 5-5 0-4.42-4.03-8-9-8zm-5.5 9c-.83 0-1.5-.67-1.5-1.5S5.67 9 6.5 9 8 9.67 8 10.5 7.33 12 6.5 12zm3-4C8.67 8 8 7.33 8 6.5S8.67 5 9.5 5s1.5.67 1.5 1.5S10.33 8 9.5 8zm5 0c-.83 0-1.5-.67-1.5-1.5S13.67 5 14.5 5s1.5.67 1.5 1.5S15.33 8 14.5 8zm3 4c-.83 0-1.5-.67-1.5-1.5S16.67 9 17.5 9s1.5.67 1.5 1.5-.67 1.5-1.5 1.5z"/></svg>
                    <span>Tema</span>
                </button>

                <div style="flex-grow:1;"></div>

                <button class="btn-neon" onclick="manualReset()" style="color:#ff4757; border-color:rgba(255,71,87,0.3)">
                    <svg viewBox="0 0 24 24"><path d="M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6 0 1.1-.27 2.12-.74 3.02l1.53 1.53C19.65 16.17 20 14.14 20 12c0-4.42-3.58-8-8-8zm-5.47 2.47l1.53 1.53C7.27 9.88 7 10.9 7 12c0 3.31 2.69 6 6 6v-4l5 5-5 5v-4c-4.42 0-8-3.58-8-8 0-2.14.35-4.17.96-5.99z"/></svg>
                    <span>Reiniciar</span>
                </button>
            </div>
        </div>
    </div>

<script>
    // CONFIGURA칂츾O GERAL
    const WIDTH = 620;       
    const HEIGHT = 330;      
    const BALL_RADIUS = 10;
    const POCKET_RADIUS = 24;
    const TABLE_MARGIN = 30;

    // Contadores de Vit칩ria
    let p1Wins = 0;
    let p2Wins = 0;

    // FOR칂A M츼XIMA AJUSTADA (DE 150*0.4=60 PARA 120*0.4=48)
    const MAX_DRAG_DISTANCE = 120; // Max distance for drag input
    const POWER_MULTIPLIER = 0.4;  // Power = drag_distance * multiplier
    const MAX_POWER = MAX_DRAG_DISTANCE * POWER_MULTIPLIER; // Max power is 48

    // TEMAS
    const THEMES = [
        { primary: '#00f3ff', feltStart: '#081015', feltEnd: '#000000', lightColor: 0x00f3ff },
        { primary: '#39ff14', feltStart: '#051005', feltEnd: '#000500', lightColor: 0x39ff14 },
        { primary: '#ff0099', feltStart: '#150510', feltEnd: '#050005', lightColor: 0xff0099 },
        { primary: '#ffae00', feltStart: '#151005', feltEnd: '#050200', lightColor: 0xffae00 }
    ];
    let currentThemeIdx = 0;
    function getTheme() { return THEMES[currentThemeIdx]; }

    // CORES DAS BOLAS (Padr칚o Pool)
    const BALL_COLORS = [
        0xffffff, // 0 - Cue
        0xffd700, 0x0044ff, 0xff3333, 0x800080, 0xff8800, 0x008800, 0x880000, // 1-7 Solids
        0x111111, // 8 Black
        0xffd700, 0x0044ff, 0xff3333, 0x800080, 0xff8800, 0x008800, 0x880000  // 9-15 Stripes
    ];

    // --- THREE.JS SETUP (Bolas 3D) ---
    const scene = new THREE.Scene();
    const camera = new THREE.OrthographicCamera(WIDTH/-2, WIDTH/2, HEIGHT/2, HEIGHT/-2, 1, 1000);
    camera.position.z = 500;

    const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
    renderer.setSize(WIDTH, HEIGHT);
    renderer.domElement.id = "three-canvas";
    document.getElementById('game-inner').appendChild(renderer.domElement);

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);
    const themeLight = new THREE.PointLight(getTheme().lightColor, 0.6, 500);
    themeLight.position.set(0, 0, 150);
    scene.add(themeLight);

    // Texturas das Bolas
    function createBallTexture(n, colorHex) {
        const canvas = document.createElement('canvas');
        canvas.width = 128; canvas.height = 64;
        const ctx = canvas.getContext('2d');
        const w = canvas.width, h = canvas.height;
        const color = '#' + new THREE.Color(colorHex).getHexString();

        // Fundo
        if (n === 0) { 
            ctx.fillStyle = '#eeeeee'; ctx.fillRect(0,0,w,h);
            // Ponto vermelho na branca para ver o giro
            ctx.fillStyle = '#cc0000'; ctx.beginPath(); ctx.arc(w/2, h/2, 4, 0, Math.PI*2); ctx.fill();
        } else if (n === 8) {
            ctx.fillStyle = '#151515'; ctx.fillRect(0,0,w,h);
        } else if (n < 9) {
            ctx.fillStyle = color; ctx.fillRect(0,0,w,h);
        } else {
            ctx.fillStyle = '#eeeeee'; ctx.fillRect(0,0,w,h);
            ctx.fillStyle = color; ctx.fillRect(0, h/4, w, h/2);
        }

        // Numero
        if (n > 0) {
            ctx.fillStyle = 'white'; ctx.beginPath(); ctx.arc(w/4, h/2, 14, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(w*0.75, h/2, 14, 0, Math.PI*2); ctx.fill();
            ctx.font = 'bold 16px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillStyle = 'black';
            ctx.fillText(n, w/4, h/2+2); ctx.fillText(n, w*0.75, h/2+2);
        }
        return new THREE.CanvasTexture(canvas);
    }

    // CLASSE BOLA
    class Ball {
        constructor(x, y, number) {
            this.x = x; this.y = y;
            this.vx = 0; this.vy = 0;
            this.number = number;
            this.radius = BALL_RADIUS;
            this.active = true;
            this.falling = false;
            this.isCue = (number === 0);
            this.isEight = (number === 8);
            this.isSolid = (number > 0 && number < 8);
            this.isStripe = (number > 8);
            
            const geo = new THREE.SphereGeometry(this.radius, 32, 32);
            const mat = new THREE.MeshPhongMaterial({ 
                map: createBallTexture(number, BALL_COLORS[number]), 
                shininess: 150,
                specular: 0x444444
            });
            this.mesh = new THREE.Mesh(geo, mat);
            scene.add(this.mesh);
            this.updateMeshPosition();
        }

        update() {
            if (!this.active && !this.falling) { this.mesh.visible = false; return; }
            this.mesh.visible = true;

            if (this.falling) { 
                this.fallAnimation(); 
                return; 
            }

            // Atrito
            let friction = 0.986;
            
            // Spin s칩 se aplica ao jogador (turn === 1)
            let currentSpin = {x:0, y:0};
            if (this.isCue) {
                 currentSpin = gameState.turn === 1 ? gameState.playerSpin : gameState.botSpin;
            }

            if (this.isCue && Math.abs(currentSpin.y) > 0.1) friction += currentSpin.y * 0.002; 
            
            this.vx *= friction; this.vy *= friction;
            
            // Parar se muito lento
            if (Math.abs(this.vx) < 0.03) this.vx = 0;
            if (Math.abs(this.vy) < 0.03) this.vy = 0;

            this.x += this.vx; 
            this.y += this.vy;

            // Colis칚o com Paredes
            let hitWall = false;
            if (this.x < TABLE_MARGIN + this.radius) { this.x = TABLE_MARGIN + this.radius; this.vx *= -0.9; hitWall=true; }
            if (this.x > WIDTH - TABLE_MARGIN - this.radius) { this.x = WIDTH - TABLE_MARGIN - this.radius; this.vx *= -0.9; hitWall=true; }
            if (this.y < TABLE_MARGIN + this.radius) { this.y = TABLE_MARGIN + this.radius; this.vy *= -0.9; hitWall=true; }
            if (this.y > HEIGHT - TABLE_MARGIN - this.radius) { this.y = HEIGHT - TABLE_MARGIN - this.radius; this.vy *= -0.9; hitWall=true; }
            
            // Efeito nas tabelas (Spin lateral)
            if(hitWall && this.isCue) { 
                if(Math.abs(this.vx)>0.5) this.vy += currentSpin.x * 0.8; 
                currentSpin.x *= 0.5; // Spin lateral se dissipa ap칩s a colis칚o
            }

            // Ca칞apa
            getPockets().forEach(p => {
                let dx = this.x - p.x, dy = this.y - p.y;
                if (dx*dx + dy*dy < POCKET_RADIUS**2) {
                    this.falling = true; 
                    this.active = false; 
                    this.pocketTarget = {x:p.x, y:p.y};
                    gameState.pocketedThisTurn.push(this);
                }
            });

            this.updateMeshPosition();
            this.updateRotation();
        }

        fallAnimation() {
            this.x += (this.pocketTarget.x - this.x) * 0.25;
            this.y += (this.pocketTarget.y - this.y) * 0.25;
            const scale = this.mesh.scale.x * 0.85;
            this.mesh.scale.set(scale, scale, scale);
            this.mesh.rotation.x += 0.3; 
            this.mesh.rotation.y += 0.3;
            this.updateMeshPosition();
            
            if (scale < 0.1) {
                this.falling = false; 
                this.mesh.visible = false; 
                this.mesh.scale.set(1,1,1);
                spawnExplosion(this.pocketTarget.x, this.pocketTarget.y, getTheme().primary);
            }
        }

        updateMeshPosition() {
            this.mesh.position.x = this.x - WIDTH / 2;
            this.mesh.position.y = -(this.y - HEIGHT / 2);
            this.mesh.position.z = 0;
        }

        updateRotation() {
            // Rota칞칚o da esfera baseada na velocidade linear
            const v = Math.sqrt(this.vx**2 + this.vy**2);
            if (v > 0.01) {
                const axis = new THREE.Vector3(-this.vy, this.vx, 0).normalize();
                const q = new THREE.Quaternion().setFromAxisAngle(axis, v/this.radius);
                this.mesh.quaternion.multiplyQuaternions(q, this.mesh.quaternion);
            }
        }
    }

    function getPockets() {
        return [
            {x: TABLE_MARGIN+2, y: TABLE_MARGIN+2}, 
            {x: WIDTH/2, y: TABLE_MARGIN-5}, 
            {x: WIDTH-TABLE_MARGIN-2, y: TABLE_MARGIN+2},
            {x: TABLE_MARGIN+2, y: HEIGHT-TABLE_MARGIN-2}, 
            {x: WIDTH/2, y: HEIGHT-TABLE_MARGIN+5}, 
            {x: WIDTH-TABLE_MARGIN-2, y: HEIGHT-TABLE_MARGIN-2}
        ];
    }

    // CANVAS 2D CONTEXTS
    const ctx2D = document.getElementById('table-canvas').getContext('2d');
    const ctxFX = document.getElementById('fx-canvas').getContext('2d');
    const inputLayer = document.getElementById('input-layer');
    
    // VARI츼VEIS DE JOGO
    let balls = [], cueBall, particles = [];
    let gameState = {
        turn: 1, // 1 = Player, 2 = Bot
        p1Type: null, 
        p2Type: null,
        isMoving: false, 
        isDragging: false,
        dragStart: {x:0, y:0}, 
        dragCurrent: {x:0, y:0},
        power: 0, 
        angle: 0,
        pocketedThisTurn: [], 
        gameOver: false, 
        ballInHand: false, 
        playerSpin: {x:0, y:0}, // Spin do Jogador
        botSpin: {x:0, y:0}     // Spin do Bot
    };

    // IA STATE
    let botState = {
        phase: 'idle',
        targetBall: null,
        aimAngle: 0,
        aimPower: 0,
        scanLines: [],
        aimTargetAngle: 0, // Novo: 츽ngulo final para onde a mira deve ir
        aimTargetPower: 0, // Novo: For칞a final para onde a barra deve ir
        timer: 0
    };

    // TIMER DO JOGO
    let turnTimer = null;
    let timeLeft = 30;
    const MAX_TIME = 30;

    function startTimer() {
        clearInterval(turnTimer);
        timeLeft = MAX_TIME;
        updateTimerVisuals();
        if(gameState.gameOver) return;
        turnTimer = setInterval(() => {
            if (gameState.turn === 2 && botState.phase !== 'idle') return; 
            timeLeft -= 0.1;
            updateTimerVisuals();
            if (timeLeft <= 0) { clearInterval(turnTimer); handleTimeOut(); }
        }, 100);
    }
    function stopTimer() { clearInterval(turnTimer); }
    function updateTimerVisuals() {
        const p1 = document.getElementById('p1-timer'), p2 = document.getElementById('p2-timer');
        const offset = 175 - (175 * (timeLeft / MAX_TIME));
        if(gameState.turn === 1) {
            p1.style.strokeDashoffset = offset; p2.style.strokeDashoffset = 175;
            p1.style.stroke = timeLeft < 5 ? '#ff3333' : getTheme().primary;
        } else {
            p2.style.strokeDashoffset = offset; p1.style.strokeDashoffset = 175;
            p2.style.stroke = timeLeft < 5 ? '#ff3333' : getTheme().primary;
        }
    }
    function handleTimeOut() {
        showToast("TEMPO ESGOTADO!", true);
        gameState.ballInHand = true;
        gameState.turn = gameState.turn === 1 ? 2 : 1;
        updateHUD();
        if(gameState.turn === 2) setTimeout(initBotTurn, 1000); else startTimer();
    }

    // --- VISUALIZA칂츾O E RENDERIZA칂츾O ---

    function drawTable2D() {
        ctx2D.clearRect(0, 0, WIDTH, HEIGHT); 
        ctxFX.clearRect(0, 0, WIDTH, HEIGHT);
        
        const theme = getTheme();

        // Desenhar Mesa (Feltro)
        const grad = ctx2D.createRadialGradient(WIDTH/2, HEIGHT/2, 50, WIDTH/2, HEIGHT/2, WIDTH*0.8);
        grad.addColorStop(0, theme.feltStart); 
        grad.addColorStop(1, theme.feltEnd);
        ctx2D.fillStyle = grad; 
        ctx2D.fillRect(TABLE_MARGIN, TABLE_MARGIN, WIDTH-TABLE_MARGIN*2, HEIGHT-TABLE_MARGIN*2);

        // Desenhar Ca칞apas
        getPockets().forEach(p => {
            ctx2D.fillStyle = "#000"; 
            ctx2D.beginPath(); ctx2D.arc(p.x, p.y, POCKET_RADIUS, 0, Math.PI*2); ctx2D.fill();
            
            // Glow da ca칞apa
            ctx2D.shadowColor = theme.primary; ctx2D.shadowBlur = 10;
            ctx2D.strokeStyle = theme.primary; ctx2D.lineWidth = 2; 
            ctx2D.beginPath(); ctx2D.arc(p.x, p.y, POCKET_RADIUS-2, 0, Math.PI*2); ctx2D.stroke();
            ctx2D.shadowBlur = 0;
        });

        // --- VISUALIZA칂츾O PLAYER ---
        if (gameState.turn === 1 && !gameState.isMoving && !gameState.ballInHand) {
            // Mira e For칞a do Jogador (enquanto arrasta)
            if (gameState.isDragging) {
                const aimData = calculateAimTrajectory(cueBall, gameState.angle);
                drawAimLines(cueBall, aimData, theme.primary, false);

                // --- BARRA DE FOR칂A CIRCULAR ---
                const powerPct = Math.min(gameState.power / MAX_POWER, 1);
                const startAngle = -Math.PI / 2;
                const endAngle = startAngle + (Math.PI * 2 * powerPct);
                
                let pColor = '#39ff14';
                if(powerPct > 0.5) pColor = '#ffff00';
                if(powerPct > 0.8) pColor = '#ff0000';

                ctxFX.beginPath();
                ctxFX.arc(cueBall.x, cueBall.y, BALL_RADIUS + 12, startAngle, endAngle, false);
                ctxFX.lineWidth = 4;
                ctxFX.lineCap = 'round';
                ctxFX.strokeStyle = pColor;
                ctxFX.shadowColor = pColor;
                ctxFX.shadowBlur = 15;
                ctxFX.stroke();
                ctxFX.shadowBlur = 0;

                drawCueStick(cueBall.x, cueBall.y, gameState.angle, -20 - (gameState.power * 0.5));
            }
        }

        // --- VISUALIZA칂츾O BOT (Thinking) ---
        if (gameState.turn === 2 && !gameState.isMoving) {
            // Interpola칞칚o para Mira Lenta
            if(botState.phase === 'aiming' || botState.phase === 'shooting') {
                // Interpolar 칙ngulo
                botState.aimAngle = lerpAngle(botState.aimAngle, botState.aimTargetAngle, 0.05); // Lento
                // Interpolar for칞a (barra)
                botState.aimPower = lerp(botState.aimPower, botState.aimTargetPower, 0.1); 
            }


            if (botState.phase === 'scanning') {
                // Desenha linhas de escaneamento
                botState.scanLines.forEach(line => {
                    ctxFX.beginPath();
                    ctxFX.moveTo(cueBall.x, cueBall.y);
                    ctxFX.lineTo(line.tx, line.ty);
                    ctxFX.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                    ctxFX.setLineDash([5, 10]);
                    ctxFX.lineWidth = 1;
                    ctxFX.stroke();
                    ctxFX.setLineDash([]);
                    
                    ctxFX.beginPath(); ctxFX.arc(line.tx, line.ty, BALL_RADIUS+5, 0, Math.PI*2);
                    ctxFX.strokeStyle = 'rgba(255,255,255,0.3)'; ctxFX.stroke();
                });
            }

            if ((botState.phase === 'aiming' || botState.phase === 'shooting') && botState.targetBall) {
                // Desenha mira do Bot
                const aimData = calculateAimTrajectory(cueBall, botState.aimAngle);
                drawAimLines(cueBall, aimData, '#ff3333', true);

                // Desenha barra de for칞a do Bot
                const powerPct = Math.min(botState.aimPower / MAX_POWER, 1);
                ctxFX.beginPath();
                ctxFX.arc(cueBall.x, cueBall.y, BALL_RADIUS + 12, -Math.PI/2, -Math.PI/2 + (Math.PI*2*powerPct));
                ctxFX.lineWidth = 4; ctxFX.strokeStyle = '#ff3333'; ctxFX.stroke();

                drawCueStick(cueBall.x, cueBall.y, botState.aimAngle, -20 - (botState.aimPower * 0.5));
            }
        }

        // --- VISUALIZA칂츾O BALL IN HAND ---
        if (gameState.ballInHand && gameState.turn === 1) {
            const time = Date.now() * 0.005;
            const pulse = 1 + Math.sin(time) * 0.1;
            
            ctxFX.save();
            ctxFX.translate(cueBall.x, cueBall.y);
            ctxFX.scale(pulse, pulse);
            
            ctxFX.beginPath();
            ctxFX.arc(0, 0, BALL_RADIUS * 2.5, 0, Math.PI*2);
            ctxFX.strokeStyle = theme.primary;
            ctxFX.lineWidth = 2;
            ctxFX.setLineDash([5, 5]);
            ctxFX.stroke();
            
            ctxFX.fillStyle = "#fff";
            ctxFX.font = "bold 10px Orbitron";
            ctxFX.textAlign = "center";
            ctxFX.fillText("ARRASTE", 0, -25);
            
            ctxFX.restore();
        }

        // Part칤culas (CSS ajustado: menores e mais lentas)
        for(let i=particles.length-1; i>=0; i--) {
            let p = particles[i]; 
            p.x += p.vx; p.y += p.vy; p.life -= 0.04;
            if(p.life<=0) { particles.splice(i,1); continue; }
            ctxFX.fillStyle = p.color; 
            ctxFX.globalAlpha = p.life;
            ctxFX.beginPath(); ctxFX.arc(p.x, p.y, p.size, 0, Math.PI*2); ctxFX.fill(); 
            ctxFX.globalAlpha = 1;
        }
    }

    // Interpola칞칚o Linear (para a mira do Bot)
    function lerp(a, b, t) {
        return a + (b - a) * t;
    }

    // Interpola칞칚o de 츽ngulos (garante o caminho mais curto)
    function lerpAngle(a, b, t) {
        let diff = b - a;
        while (diff > Math.PI) diff -= 2 * Math.PI;
        while (diff < -Math.PI) diff += 2 * Math.PI;
        return a + diff * t;
    }


    function drawCueStick(x, y, angle, offset) {
        ctxFX.save();
        ctxFX.translate(x, y);
        ctxFX.rotate(angle);
        ctxFX.translate(offset, 0);

        const stickGradient = ctxFX.createLinearGradient(-150, 0, 0, 0);
        stickGradient.addColorStop(0, '#333');
        stickGradient.addColorStop(0.9, '#cfaa70'); 
        stickGradient.addColorStop(1, '#fff');

        ctxFX.fillStyle = stickGradient;
        ctxFX.shadowColor = '#000'; ctxFX.shadowBlur = 5;
        ctxFX.beginPath();
        ctxFX.moveTo(-200, -4); 
        ctxFX.lineTo(0, -2);    
        ctxFX.lineTo(0, 2);
        ctxFX.lineTo(-200, 4);
        ctxFX.fill();

        ctxFX.restore();
    }

    function drawAimLines(startBall, aimData, color, isBot) {
        ctxFX.beginPath(); 
        ctxFX.moveTo(startBall.x, startBall.y); 
        ctxFX.lineTo(aimData.endX, aimData.endY);
        ctxFX.lineWidth = 2; 
        ctxFX.setLineDash([4, 4]); 
        ctxFX.strokeStyle = color;
        ctxFX.shadowColor = color; 
        ctxFX.shadowBlur = isBot ? 5 : 10; 
        ctxFX.stroke(); 
        ctxFX.shadowBlur = 0; 
        ctxFX.setLineDash([]);
        
        if (aimData.target) {
            ctxFX.beginPath(); 
            ctxFX.arc(aimData.endX, aimData.endY, BALL_RADIUS, 0, Math.PI*2);
            ctxFX.strokeStyle = color; 
            ctxFX.stroke();
            
            const impactAngle = Math.atan2(aimData.target.y - aimData.endY, aimData.target.x - aimData.endX);
            ctxFX.beginPath();
            ctxFX.moveTo(aimData.endX, aimData.endY);
            ctxFX.lineTo(aimData.endX + Math.cos(impactAngle)*30, aimData.endY + Math.sin(impactAngle)*30);
            ctxFX.lineWidth = 1;
            ctxFX.strokeStyle = 'rgba(255,255,255,0.5)';
            ctxFX.stroke();
        }
    }

    function calculateAimTrajectory(source, angle) {
        const dx = Math.cos(angle), dy = Math.sin(angle);
        let maxDist = 800, bestDist = maxDist, targetBall = null;
        
        balls.forEach(b => {
            if (!b.active || b === source || b.falling) return;
            
            const vx = b.x - source.x, vy = b.y - source.y;
            const t = vx * dx + vy * dy; 
            
            if (t > 0) {
                const closestDistSq = (vx*vx + vy*vy) - (t*t); 
                if (closestDistSq < (BALL_RADIUS * 2)**2) { 
                    const dt = Math.sqrt((BALL_RADIUS * 2)**2 - closestDistSq);
                    if (t - dt < bestDist && t - dt > 0) { 
                        bestDist = t - dt; 
                        targetBall = b; 
                    }
                }
            }
        });
        
        if (!targetBall) {
           bestDist = 400; 
        }

        return { 
            distance: bestDist, 
            target: targetBall, 
            endX: source.x + dx * bestDist, 
            endY: source.y + dy * bestDist 
        };
    }

    // --- INPUT DO JOGADOR ---
    function getMousePos(evt) {
        const rect = inputLayer.getBoundingClientRect();
        return { x: (evt.clientX - rect.left) * (WIDTH/rect.width), y: (evt.clientY - rect.top) * (HEIGHT/rect.height) };
    }
    
    function handleInputStart(e) {
        const pos = getMousePos(e);
        if (gameState.turn !== 1 || gameState.isMoving || gameState.gameOver) return;
        
        if (gameState.ballInHand) {
             gameState.isDragging = true; 
             return; 
        }

        const dx = pos.x - cueBall.x, dy = pos.y - cueBall.y;
        if (dx*dx + dy*dy < BALL_RADIUS*BALL_RADIUS * 25) { 
            gameState.isDragging = true; 
            gameState.dragStart = {x: cueBall.x, y: cueBall.y}; 
            gameState.dragCurrent = pos;
        }
    }

    function handleInputMove(e) {
        const pos = getMousePos(e);
        
        if (gameState.ballInHand && gameState.isDragging && gameState.turn === 1) {
            cueBall.x = Math.max(TABLE_MARGIN+BALL_RADIUS, Math.min(WIDTH-TABLE_MARGIN-BALL_RADIUS, pos.x));
            cueBall.y = Math.max(TABLE_MARGIN+BALL_RADIUS, Math.min(HEIGHT-TABLE_MARGIN-BALL_RADIUS, pos.y));
            
            cueBall.vx = 0; cueBall.vy = 0;
            cueBall.updateMeshPosition(); 
            return;
        }

        if (gameState.isDragging && !gameState.ballInHand) {
            gameState.dragCurrent = pos;
            const dx = gameState.dragStart.x - pos.x, dy = gameState.dragStart.y - pos.y; 
            gameState.angle = Math.atan2(dy, dx); 
            // Limitar a for칞a de arrasto ao novo m치ximo (MAX_DRAG_DISTANCE)
            gameState.power = Math.min(Math.hypot(dx, dy), MAX_DRAG_DISTANCE) * POWER_MULTIPLIER; 
        }
    }

    function handleInputEnd() {
        if (!gameState.isDragging) return;
        gameState.isDragging = false;
        
        if (gameState.ballInHand) { 
            let collision = false;
            balls.forEach(b => {
                if(b!==cueBall && b.active && Math.hypot(b.x-cueBall.x, b.y-cueBall.y) < BALL_RADIUS*2) collision = true;
            });
            
            if(collision) {
                showToast("POSI칂츾O INV츼LIDA", true);
            } else {
                gameState.ballInHand = false; 
                showToast("POSICIONADO!"); 
            }
            return; 
        }

        if (gameState.power > 2) {
             // Zera o spin do bot para garantir que s칩 o playerSpin seja usado
             gameState.botSpin = {x:0, y:0};
             shoot(gameState.angle, gameState.power);
        }
    }

    inputLayer.addEventListener('mousedown', handleInputStart);
    inputLayer.addEventListener('touchstart', (e)=>handleInputStart(e.touches[0]), {passive:false});
    window.addEventListener('mousemove', handleInputMove);
    window.addEventListener('touchmove', (e)=>handleInputMove(e.touches[0]), {passive:false});
    window.addEventListener('mouseup', handleInputEnd);
    window.addEventListener('touchend', handleInputEnd);


    // --- L칍GICA F칈SICA E REGRAS ---
    function shoot(a, p) {
        stopTimer();
        gameState.pocketedThisTurn = []; 
        cueBall.vx = Math.cos(a) * p; 
        cueBall.vy = Math.sin(a) * p;
        gameState.isMoving = true; 
        gameState.power = 0;
        botState.phase = 'idle'; 
        // Esconder spin do Bot se estava vis칤vel
        document.getElementById('bot-spin-dot').style.opacity = 0;
    }

    function checkCollisions() {
        // Obter o spin apropriado para esta jogada
        const currentSpin = gameState.turn === 1 ? gameState.playerSpin : gameState.botSpin;

        for (let i=0; i<balls.length; i++) {
            for (let j=i+1; j<balls.length; j++) {
                let b1 = balls[i], b2 = balls[j];
                if (!b1.active || !b2.active || b1.falling || b2.falling) continue;
                
                let dx = b2.x - b1.x, dy = b2.y - b1.y, dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < BALL_RADIUS*2) {
                    let angle = Math.atan2(dy, dx);
                    let overlap = (BALL_RADIUS*2 - dist) / 2;
                    
                    b1.x -= Math.cos(angle)*overlap; b1.y -= Math.sin(angle)*overlap;
                    b2.x += Math.cos(angle)*overlap; b2.y += Math.sin(angle)*overlap;
                    
                    let v1 = rotate({x:b1.vx, y:b1.vy}, -angle);
                    let v2 = rotate({x:b2.vx, y:b2.vy}, -angle);
                    let f1 = {x:v2.x, y:v1.y}; 
                    let f2 = {x:v1.x, y:v2.y};
                    
                    let vf1 = rotate(f1, angle);
                    let vf2 = rotate(f2, angle);
                    
                    b1.vx = vf1.x * 0.97; b1.vy = vf1.y * 0.97; 
                    b2.vx = vf2.x * 0.97; b2.vy = vf2.y * 0.97;

                    // Aplica Spin apenas da bola branca (b1 ou b2) para a outra
                    if(b1.isCue) { 
                        b2.vx += currentSpin.x * 0.5; 
                        b2.vy += currentSpin.y * 0.5; 
                    } else if (b2.isCue) {
                         b1.vx += currentSpin.x * 0.5; 
                         b1.vy += currentSpin.y * 0.5;
                    }
                    
                    // Colis칚o visual suave (apenas se muito forte)
                    if(Math.hypot(b1.vx, b1.vy) > 15) spawnExplosion((b1.x+b2.x)/2, (b1.y+b2.y)/2, '#fff');
                }
            }
        }
    }
    function rotate(v, a) { return { x: v.x*Math.cos(a) - v.y*Math.sin(a), y: v.x*Math.sin(a) + v.y*Math.cos(a) }; }

    function checkStop() {
        let moving = false;
        balls.forEach(b => { if ((b.active && Math.hypot(b.vx, b.vy) > 0.05) || b.falling) moving = true; });
        
        if (gameState.isMoving && !moving) { 
            gameState.isMoving = false; 
            handleTurnEnd(); 
        }
    }

    function triggerGameOver(winnerId) {
        gameState.gameOver = true;
        stopTimer();
        
        if(winnerId === 1) {
            showToast("VIT칍RIA!", false);
            p1Wins++;
        } else {
            showToast("BOT VENCEU!", true);
            p2Wins++;
        }
        updateWinsDisplay();
        
        // Rein칤cio Autom치tico
        setTimeout(() => {
            initGame();
        }, 4000);
    }

    function handleTurnEnd() {
        let foul = false, turnContinues = false, msg = "";
        
        // 1. Branca Caiu?
        const cueFell = gameState.pocketedThisTurn.find(b => b.isCue);
        if (cueFell) {
            foul = true; msg = "FALTA: BRANCA CAIU";
            cueBall.active = true; cueBall.mesh.visible = true; cueBall.mesh.scale.set(1,1,1);
            cueBall.x = WIDTH/4; cueBall.y = HEIGHT/2; cueBall.vx=0; cueBall.vy=0;
            gameState.ballInHand = true;
        }

        // 2. Bola 8
        const eightBallFell = gameState.pocketedThisTurn.find(b => b.number === 8);
        if (eightBallFell) {
            if (cueFell) { triggerGameOver(gameState.turn === 1 ? 2 : 1); return; } // Perdeu (caiu branca + 8)
            
            let myType = gameState.turn===1 ? gameState.p1Type : gameState.p2Type;
            if (!myType) { triggerGameOver(gameState.turn === 1 ? 2 : 1); return; } // Perdeu (8 muito cedo)

            let remaining = balls.filter(b => b.active && !b.isCue && !b.isEight && (myType==='solids'?b.isSolid:b.isStripe)).length;
            
            if (remaining === 0) { 
                triggerGameOver(gameState.turn); // Ganhou!
                return; 
            } 
            else { 
                triggerGameOver(gameState.turn === 1 ? 2 : 1); // Perdeu (ainda tinha bolas)
                return; 
            }
        }

        // 3. Bolas Normais
        if (!foul && gameState.pocketedThisTurn.length > 0) {
            let sunkOwn = false, sunkOpp = false;
            gameState.pocketedThisTurn.forEach(b => {
                if (!b.isCue && !b.isEight) {
                    let type = b.isSolid ? 'solids' : 'stripes';
                    if (!gameState.p1Type) {
                        gameState.p1Type = (gameState.turn===1) ? type : (type==='solids'?'stripes':'solids');
                        gameState.p2Type = (gameState.p1Type==='solids') ? 'stripes' : 'solids';
                        updateTypeLabels();
                        showToast(`VOC칅 칄 ${gameState.p1Type === 'solids' ? 'LISAS' : 'LISTRADAS'}`);
                    }
                    if ((gameState.turn===1 ? gameState.p1Type : gameState.p2Type) === type) sunkOwn = true; else sunkOpp = true;
                }
            });
            if (sunkOwn && !sunkOpp) turnContinues = true;
            else if (sunkOpp) { msg = "BOLA ADVERS츼RIA"; foul = true; }
        }

        gameState.pocketedThisTurn = [];
        
        if (foul || !turnContinues) { 
            if(msg) showToast(msg, true);
            gameState.turn = gameState.turn===1?2:1; 
            if(foul && !gameState.ballInHand) gameState.ballInHand = true; 
        } else {
             if(gameState.turn === 1) showToast("SUA VEZ CONTINUA", false);
             else showToast("BOT CONTINUA", true);
        }

        updateHUD();
        if (!gameState.gameOver) {
            startTimer();
            if (gameState.turn === 2) initBotTurn();
        }
    }

    // --- SISTEMA DE BOT AVAN칂ADO (COM MIRA LENTA) ---
    function initBotTurn() {
        if (gameState.gameOver) return;
        
        // Zera o spin do bot no in칤cio da jogada
        gameState.botSpin = {x:0, y:0};

        if (gameState.ballInHand) {
            // Reposicionamento mais esperto se poss칤vel
            let pos = {x: WIDTH/4 + (Math.random()-0.5)*50, y: HEIGHT/2 + (Math.random()-0.5)*100};
            // Checar colis칚o na posi칞칚o
            let validPos = false;
            let attempts = 0;
            while(!validPos && attempts++ < 10) {
                 validPos = true;
                 balls.forEach(b => {
                    if(b!==cueBall && b.active && Math.hypot(b.x-pos.x, b.y-pos.y) < BALL_RADIUS*2.5) validPos = false;
                 });
                 if(!validPos) pos = {x: WIDTH/4 + (Math.random()-0.5)*100, y: HEIGHT/2 + (Math.random()-0.5)*100};
            }
            cueBall.x = pos.x; 
            cueBall.y = pos.y;
            cueBall.updateMeshPosition();
            gameState.ballInHand = false;
        }

        let targets = balls.filter(b => b.active && !b.isCue && !b.isEight);
        if (gameState.p2Type) targets = targets.filter(b => gameState.p2Type==='solids'?b.isSolid:b.isStripe);
        if (targets.length===0) targets = balls.filter(b => b.active && b.isEight);
        
        if (targets.length === 0) return;

        botState.phase = 'scanning';
        botState.scanLines = [];
        
        // Exibe 3 linhas de escaneamento para dar a ideia de "an치lise"
        for(let i=0; i<3; i++) {
            let rBall = targets[Math.floor(Math.random() * targets.length)];
            botState.scanLines.push({tx: rBall.x, ty: rBall.y});
        }

        let best = null, minD = Infinity;
        targets.forEach(t => {
            getPockets().forEach(p => {
                let a = Math.atan2(p.y - t.y, p.x - t.x);
                let ax = t.x - Math.cos(a)*BALL_RADIUS*2;
                let ay = t.y - Math.sin(a)*BALL_RADIUS*2;
                let aimAngle = Math.atan2(ay - cueBall.y, ax - cueBall.x);
                let d = Math.hypot(ax-cueBall.x, ay-cueBall.y);
                let cutAngle = Math.abs(a - aimAngle);
                while(cutAngle > Math.PI) cutAngle -= Math.PI*2;
                cutAngle = Math.abs(cutAngle);

                // Crit칠rio de escolha: Dist칙ncia e 칙ngulo de corte (n칚o pode ser muito fino)
                if (d < minD && cutAngle < Math.PI/2.2) { 
                    minD = d;
                    let error = (Math.random()-0.5) * 0.05; // Pequeno erro na mira do Bot
                    best = { 
                        ball: t,
                        angle: aimAngle + error, 
                        // Power ajustado para o novo MAX_POWER
                        power: Math.min(d*0.35 + 20, MAX_POWER - 5) 
                    };
                }
            });
        });

        if (!best) {
            let t = targets[0];
            best = { ball: t, angle: Math.atan2(t.y-cueBall.y, t.x-cueBall.x), power: MAX_POWER/2 };
        }

        botState.targetBall = best.ball;
        botState.finalChoice = best;
        botState.aimTargetAngle = best.angle;
        botState.aimTargetPower = best.power; 
        
        // Inicializa a mira do bot na dire칞칚o do alvo, mas com for칞a 0
        botState.aimAngle = Math.atan2(best.ball.y - cueBall.y, best.ball.x - cueBall.x);
        botState.aimPower = 0;


        setTimeout(() => {
            botState.phase = 'aiming';
            
            // Define o spin do bot (randomizado e independente do jogador)
            gameState.botSpin.x = (Math.random()-0.5) * 1.5; // Mais chance de n칚o ser 0
            gameState.botSpin.y = (Math.random()-0.5) * 1.5;
            
            // Exibir o ponto de spin do bot (verde)
            const d = document.getElementById('bot-spin-dot');
            d.style.left = (gameState.botSpin.x/2+0.5)*100+'%'; 
            d.style.top = (gameState.botSpin.y/2+0.5)*100+'%';
            d.style.opacity = 1;


        }, 1000); 

        // Atira ap칩s um tempo de mira e carregamento visual
        setTimeout(() => {
            if(!gameState.gameOver) {
                 botState.phase = 'shooting'; // Fase de tiro (barra de for칞a preenche)
                 let chargeInterval = setInterval(() => {
                    if(botState.aimPower < botState.aimTargetPower - 0.5) {
                        botState.aimPower = lerp(botState.aimPower, botState.aimTargetPower, 0.2);
                    } else {
                        clearInterval(chargeInterval);
                        shoot(botState.aimTargetAngle, botState.aimTargetPower); // Tiro final
                    }
                }, 20);
            }
        }, 3000);
    }


    // --- UI UPDATES ---
    function updateHUD() {
        const theme = getTheme();
        document.getElementById('p1-section').classList.toggle('active-turn', gameState.turn === 1);
        document.getElementById('p2-section').classList.toggle('active-turn', gameState.turn === 2);
        
        // Se for a vez do bot, esconde o spin do jogador e mostra o do bot
        document.getElementById('spin-dot').style.opacity = gameState.turn === 1 ? 1 : 0;
        document.getElementById('bot-spin-dot').style.opacity = gameState.turn === 2 && botState.phase !== 'idle' ? 1 : 0;

        const updateDots = (id, type) => {
            const el = document.getElementById(id); el.innerHTML = '';
            if (!type) return;
            let count = balls.filter(b => b.active && !b.isCue && !b.isEight && (type==='solids'?b.isSolid:b.isStripe)).length;
            let total = 7;
            let scored = total - count;
            
            for(let i=0; i<scored; i++) {
                let d = document.createElement('div'); d.className = 'dot active'; 
                d.style.background = theme.primary; d.style.boxShadow = `0 0 5px ${theme.primary}`;
                el.appendChild(d);
            }
            for(let i=0; i<count; i++) el.appendChild(document.createElement('div'));
        };
        updateDots('p1-score', gameState.p1Type);
        updateDots('p2-score', gameState.p2Type);
    }

    function updateWinsDisplay() {
        document.getElementById('p1-wins-display').innerText = "VIT칍RIAS: " + p1Wins;
        document.getElementById('p2-wins-display').innerText = "VIT칍RIAS: " + p2Wins;
    }

    function updateTypeLabels() {
        const p1L = document.getElementById('p1-type-label'), p2L = document.getElementById('p2-type-label');
        if(gameState.p1Type) {
            p1L.innerText = gameState.p1Type === 'solids' ? 'LISAS (1-7)' : 'LISTRADAS (9-15)';
            p2L.innerText = gameState.p2Type === 'solids' ? 'LISAS (1-7)' : 'LISTRADAS (9-15)';
        } else { p1L.innerText = '--'; p2L.innerText = '--'; }
    }

    // TOAST MENOR (AJUSTADO NO CSS E NO DURATION)
    function showToast(msg, isBad=false) {
        const el = document.getElementById('game-toast');
        el.innerText = msg; 
        if(isBad) el.classList.add('bad'); else el.classList.remove('bad');
        el.classList.add('show');
        setTimeout(()=>el.classList.remove('show'), 1500); // Dura칞칚o menor
    }

    // EFEITO DE EXPLOS츾O AJUSTADO (MENOR)
    function spawnExplosion(x, y, color) {
        for(let i=0; i<8; i++) {
            particles.push({
                x, y, 
                vx:(Math.random()-0.5)*2.5, 
                vy:(Math.random()-0.5)*2.5, 
                life:1.0, 
                color, 
                size:Math.random()*2+1
            });
        }
    }

    // --- CONTROLES DE MENU ---
    let spinMenuOpen = false;
    function toggleSpinMenu() { 
        spinMenuOpen = !spinMenuOpen; 
        document.getElementById('spin-popover').classList.toggle('visible', spinMenuOpen); 
    }
    
    document.getElementById('spin-control').addEventListener('mousedown', setSpin);
    document.getElementById('spin-control').addEventListener('touchstart', (e)=>{e.preventDefault(); setSpin(e.touches[0])});
    
    function setSpin(e) {
        const rect = e.target.getBoundingClientRect();
        let sx = ((e.clientX - rect.left)/rect.width - 0.5)*2;
        let sy = ((e.clientY - rect.top)/rect.height - 0.5)*2;
        if(sx*sx+sy*sy > 1) { let d=Math.sqrt(sx*sx+sy*sy); sx/=d; sy/=d; }
        gameState.playerSpin = {x:sx, y:sy}; // Define o spin do JOGADOR
        const d = document.getElementById('spin-dot'); 
        d.style.left = (sx/2+0.5)*100+'%'; 
        d.style.top = (sy/2+0.5)*100+'%';
    }

    function cycleTheme() {
        currentThemeIdx = (currentThemeIdx + 1) % THEMES.length;
        const theme = getTheme();
        document.documentElement.style.setProperty('--primary-color', theme.primary);
        themeLight.color.setHex(theme.lightColor);
        updateHUD(); drawTable2D(); 
    }

    function initGame() {
        // Limpar Three.js
        balls.forEach(b => scene.remove(b.mesh));
        balls = [];
        
        // Criar Bolas
        cueBall = new Ball(WIDTH*0.25, HEIGHT/2, 0); 
        balls.push(cueBall);
        
        let startX = WIDTH*0.72, startY = HEIGHT/2;
        let s = BALL_RADIUS*2.02; // Espa칞amento
        let h = s*Math.sin(Math.PI/3);
        
        // Padr칚o de Rack 8-ball
        const rows = [
            [1], 
            [9,2], 
            [10,8,3], 
            [11,5,12,4], 
            [13,6,14,7,15]
        ];
        
        rows.forEach((row, i) => {
            let ry = startY - ((row.length-1)*s)/2;
            row.forEach((n, j) => balls.push(new Ball(startX + i*h, ry + j*s, n)));
        });

        gameState.turn=1; 
        gameState.gameOver=false; 
        gameState.p1Type=null; 
        gameState.p2Type=null;
        gameState.ballInHand=false; 
        gameState.playerSpin={x:0,y:0}; // Resetar Spin do jogador
        gameState.botSpin={x:0,y:0};   // Resetar Spin do bot
        gameState.pocketedThisTurn = [];
        
        // Reset Spin UI do jogador
        const d = document.getElementById('spin-dot'); 
        d.style.left = '50%'; d.style.top = '50%';
        d.style.opacity = 1;

        // Reset Spin UI do bot
        document.getElementById('bot-spin-dot').style.opacity = 0;

        updateTypeLabels(); 
        updateHUD();
        updateWinsDisplay(); 
        showToast("QUEBRE!", false); 
        startTimer();
    }

    // Fun칞칚o do Bot칚o Reiniciar 
    function manualReset() { initGame(); }
    
    // LOOP PRINCIPAL
    function animate() {
        requestAnimationFrame(animate);
        
        if (gameState.isMoving) { 
            balls.forEach(b => b.update()); 
            checkCollisions(); 
            checkStop(); 
        } 
        
        // A mira do bot 칠 atualizada mesmo se n칚o estiver "isMoving" para a anima칞칚o lenta
        if (gameState.turn === 2 && !gameState.isMoving && (botState.phase === 'aiming' || botState.phase === 'shooting')) {
            // Chamada para for칞ar a atualiza칞칚o visual da mira (que depende de botState.aimAngle)
             drawTable2D(); 
        } else {
            drawTable2D();
        }

        renderer.render(scene, camera);
    }

    // Iniciar
    initGame();
    animate();

</script>
</body>
</html>
